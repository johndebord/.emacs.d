// TODO:
// Consider: explicit, inline, noexcept

#include <cstring> // memcpy, strlen, strcpy
#include <stdexcept> // std::out_of_range
#include <iostream>

#include "eostring.hpp"

using uint8_t = unsigned char;

// namespace eostring_impl
// {
//     char* strcpy(char* d, const char* s)
//     {
//         while(*d++ = *s++);
//         return d;
//     }
    
//     size_t strlen(const char* s)
//     {
//         size_t len{};
//         while(*s++, ++len);
//         return len;
//     }

//     void* memcpy(void* d, const void* s, size_t n )
//     {
//         while (n--) *cp++ = static_cast<uint8_t>(*s)++;
//         return d;
//     }
// };

class eostring;

static constexpr size_t npos(-1);
static const eostring empty_str{""};

eostring::eostring()
{
    _size = 0;
    _capacity = 0;
    _begin = nullptr;
}

eostring::eostring(const eostring& s)
{
    _size = s.size();
    _capacity = _size; // Change once allocator implemented
    _begin = new char[_size];
    strcpy(_begin, s.data());
}

eostring::eostring(const eostring& s, size_t pos, size_t len = npos)
{
    _size = len - pos;
    _capacity = _size; // Change once allocator implemented
    _begin = new char[_size];
    strcpy(_begin, s.data());
}

eostring::eostring(const char* s)
{
}

eostring::eostring(const char* s, size_t n)
{
}

eostring::eostring(size_t n, char c)
{
}

template <class InputIterator>
eostring::eostring(InputIterator first, InputIterator last)
{
}

eostring::eostring(std::initializer_list<char> il)
{
}

eostring::eostring(eostring&& s)
{
}

eostring& eostring::operator=(const eostring& s)
{
}

eostring& eostring::operator=(const char* s)
{
}

eostring& eostring::operator=(char c)
{
}

eostring& eostring::operator=(std::initializer_list<char> il)
{
}

eostring& eostring::operator=(eostring&& s)
{
}

// assign

// get_allocator

char& eostring::at(size_t n)
{
    if (n >= _size)
        throw std::out_of_range{"Invalid index"};
    return _begin[n];
}

const char& eostring::at(size_t n) const
{
    if (n >= _size)
        throw std::out_of_range{"Invalid index"};
    return _begin[n];
}

char& eostring::operator[](size_t n)
{
    return _begin[n];
}

const char& eostring::operator[](size_t n) const
{
    return _begin[n];
}

char& eostring::front()
{
    return _begin[0];
}

const char& eostring::front() const
{
    return _begin[0];
}

char& eostring::back()
{
    return _begin[_size-1];
}

const char& eostring::back() const
{
    return _begin[_size-1];
}

char* eostring::data()
{
    return _begin;
}

const char* eostring::data() const
{
    return _begin;
}

const char* eostring::c_str() const
{ 
    return _begin;
}

char* eostring::begin()
{
    return &_begin[0];
}

const char* eostring::cbegin() const
{
    return &_begin[0];
}

char* eostring::end()
{
    return &_begin[_size];
}

const char* eostring::cend() const
{
    return &_begin[_size];
}

// char* eostring::rbegin()
// {
//     return &_begin[0];
// }

// const char* eostring::crbegin() const
// {
//     return &_begin[0];
// }

// char* eostring::rend()
// {
//     return &_begin[_size];
// }

// const char* eostring::crend() const
// {
//     return &_begin[_size];
// }

bool eostring::empty() const
{
    return !!_size;
}

size_t eostring::size() const
{
    return _size;
}

size_t eostring::length() const
{
    return _size;
}

size_t eostring::max_size() const
{
    return size_t(-1);
}

// reserve

// shrink_to_fit

// clear
// insert
// erase
// push_back
// pop_back
// append
// operator+=
// compare
// starts_with
// ends_with
// replace
// substr
// copy
// resize
// resize
// swap

size_t eostring::capacity() const
{
    return _capacity;
}

eostring::~eostring()
{
}

#include <string>
#include <sys/mman.h>
#include <unistd.h>
#include <iomanip>
#include <errno.h>
#include <csignal>
#include <memory>

using namespace std;

void print_error(int err);

int main()
{
    // Acceptable Range:
    // 0x00000000 - 0xBFFFFFFF
    
    // Target Range:
    // 0xBFFFFFFFFFFFFFFF
    // 0x0077206f6c6c6548
    // 0x00212121646c726f
    // 0x0000000000000000
    // size_t first_part {0x0077206f6c6c6548};
    // size_t second_part{0x00212121646c726f};
    // munmap((void*)0x0077206f6c6c6548,1);
    // 0x48656c6c6f207700                 fffffffffff

    // cout << hex << htobe64(0x6865792C20776F00) << endl;
    // cout << hex << htobe64(0x726C642100000000) << endl;








































    size_t first_part {0x006f77202c796568}; // hey, wo
    // size_t second_part{0x0000000021646c72}; // porld!

    static constexpr size_t len{500};
    size_t* map = (size_t*)mmap((void*)(0x0000000021646000),len,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,-1,0);
                                          
    if(map == MAP_FAILED) {
        cout << "failed\n";
        print_error(errno);
    } else {
        // cout << &map[0]   << '\t' << map[0] << endl;
        // cout << hex       << "0x" << second_part << endl;
        // cout << &map[len] << '\t' << map[len] << endl;
    }

    size_t offset{398};
    // cout << dec << offset << endl;
    // cout << &map[offset] << '\t' << map[offset] << endl;

    map[offset] = first_part;
    // cout << hex <<&map[offset] << '\t' << map[offset] << endl;

    cout << reinterpret_cast<const char*>(&map[offset]) << endl;
    cout << reinterpret_cast<const char*>(std::addressof(map+offset)) << endl;
    
    // cout << reinterpret_cast<const char*>(map+offset) << endl;
    // cout << map+offset << endl;
    // size_t temp = (size_t)(map+offset);
    // cout << hex << temp << endl;










































    
    // cout << &map[0] << endl;
    
    // cout << sysconf(_SC_PAGE_SIZE) <<endl;
    // cout << (size_t)0x0077206f6c6c6548/(size_t)4096 <<endl;
    // double d{33531185161069896};
    // double d{8186324502214};
    // double res = d / 4096;
    // cout << setprecision(17) << res << endl;
    // cout << &map[0] << endl;
    // cout << map+1 << endl;
    // char* str = (char*)&first_part;
    // cout << str;
    // str = (char*)&second_part;
    // cout << str << endl;
    

    // char* p1 = &first_part

    // cout << reinterpret_cast<const char*>(&map) << endl;
    // cout << reinterpret_cast<const char**>(&map[0]) << endl;
    

    // cout << &str << endl;
    // cout << reinterpret_cast<const char*>(&str) << endl;
    // cout << reinterpret_cast<const char*>(str) << endl;
    
    // constexpr size_t len = 3000000000;
    // int* p = new int[len];
    // cout << &p << endl;
    // cout << &p+len << endl;
    
    // cout << sizeof(int*) << endl;

    // size_t* sp;
    // size = reinterpret_cast<size_t>((size_t)p >> 16);

    // 0x0000776F6C6C6568
    
    // 0x00007ffc3d67a9e8
    // 0x00008001d3ea99e8
    
    // cout << &p << endl;
    // &p = reinterpret_cast<char*>(0x006F6C6C6568);
    // char* p{reinterpret_cast<char*>(0x006F6C6C6568)};

    return 0;
}

void print_error(int err)
{
    switch(err)
    {
        case EACCES:
            cout << "EACCES\n";
            break;
        case EAGAIN:
            cout << "EAGAIN\n";
            break;
        case EBADF:
            cout << "EBADF\n";
            break;
        case EINVAL:
            cout << "EINVAL\n";
            break;
        case ENFILE:
            cout << "ENFILE\n";
            break;
        case ENODEV:
            cout << "ENODEV\n";
            break;
        case ENOMEM:
            cout << "ENOMEM\n";
            break;
        case EPERM:
            cout << "EPERM\n";
            break;
        case ETXTBSY:
            cout << "ETXTBSY\n";
            break;
        case EOVERFLOW:
            cout << "EOVERFLOW\n";
            break;
        case SIGBUS:
            cout << "SIGBUS\n";
            break;
        default:
            break;
    }
}
