*  == Finished with pre-std section
** == Finished post-std section
TODO: Modify each occurance of: `§` (decide what to do with their questions)
TODO: Make sure data structures have the appropriate `_*` syntax
TODO: Make all functions appropriately constexpr where need be
TODO: Double check `"Erroneous behavior encountered.\n"` for consistency.
TODO: Delete all trailing whitespace
TODO: Untabiy file
TODO: Put after-code question statements before the question code
TODO: Make sure every `main` function returns 0
TODO: Write an intro to the document
TODO: Paragraph fill the entire document to an appropriate length
TODO: Be consistent with the questions I've answer with '|' separators
TODO: Make sure all macro `\` are of appropriate spacing
TODO: Make sure all question numbers are in order
TODO: Make sure all class names follow the same consistent convention
TODO: Ensure proper punctuation in all questions
TODO: Give class names the prefix `jd_*` where appropriate
TODO: Make sure all class names (in examples and in code) are lowercased
TODO: Make sure all "``" pairs are consistent
TODO: Make sure all question numbers are in order and accurate
TODO: Make sure all questions are properly formed
TODO: When implementing an STL-like class, make sure to prefix it as `jd_*`
TODO: Compare the speed of accumulating with pointers vs `size_t`
TODO: Keep a consistent class definition style
TODO: Check the headers in each implementation and remove which ones are unused; and give correct spacing
TODO: `ispell` the entire buffer for spelling errors
TODO: For my new syntax style, make sure that there is always `{ }` around minimal `if`s/loops/etc.
TODO: Decide if I want to go the multiple '|' route for questions with pre-made code snippets
TODO: Make all variable names consistent
TODO: Be consistent with optimization comments; example: `bignum`
TODO: Be consistent with commented out lines that are intended to be commented out
TODO: Appropriately give types in function as opposed to functions? e.g., `std::ostream` instead of `std::cout`?
TODO: Update all question numbers appropriately
TODO: Double check variable name consistency in all implementations
TODO: Check for double deletion on the SFML code
TODO: Make sure the correct syntax of `virtual`, `override`, and `final` are used
TODO: Make sure I apply `const` appropriately to all functions in a data structure
TODO: Check all virtual destructors if I really need them
TODO: Correct spacing of `()`, `~()`, etc.
TODO: Should asserts have `` when referring to types? Also check if all types in strings should be enclosed in ``
TODO: Make sure correct spacings of `while ()`, `for ()`, `if ()`, etc.
TODO: Make ':' at the end of a question consistent with the whole document

A few questions are skipped due to the redundancy of the question in relation to previous questions and/or due to time constraints of my personal study-time.

------------------------------
X.2 The Structure of This Book
------------------------------
[X][1]  (*2) Briefly describe the design aims of C++ and comment on the extent to which C++ meets those.
             - C++ gives the author a set of fundamental primitives and abstraction mechanisms, that when interelated properly, can bring abstract ideas to life.
               And with that provide access to such low-level facilities like no other language (for if there were such a language, one would prefer such
               language). The core abstractions provided by C++ are not high-level. But an author may conduct said lower-level abstractions to manifest
               higher-level abstractions.
             - Since the dawn of the language's creation, object-oriented design and speed have been the primary factors in its implementation.
             
[X][2]  (*2) What can a good programming language do for you and what can’t you expect it to help with?
             - A good programming language can provide you with the necessary abstractions needed to bring your ideas to life.
               What a good programming language can't do for you is write your program for you, or explicitly give you the correct design decisions;
               those are left to the author.
               
[X][3]  (*1) What are the main programming styles supported by C++?
             - C-style programming.
             - Data abstraction.
             - Objected-oriented programming.
             - Generic programming.
             
[X][4]  (*2) List five language features offered by the 1985 version of C++, five features added by C++98, and finally five new features added by C++11.
             In each case, order the features in order of importance and for each feature write a sentence describing its role in programming.
             - C++1985:
               1) Virtual functions.
               2) Function and operator overloading.
               3) References.
               4) `new` and `delete` operators.
               5) The `const` keyword.
               6) The scope resolution operator.
               
             - C++98
               1) `dynamic_cast` and `typeid`.
               2) Cast operators.
               3) `mutable`.
               4) `bool`.
               5) Template instantiations.
               6) Member templates.
               
             - C++11
                1) `auto` and `decltype`.
                2) Defaulted and deleted functions.
                3) `final` and `override`.
                4) Trailing return type.
                5) Rvalue references.
                6) Move constructors/move assignment.
                7) Scoped enumerations.
                8) `constexpr`.
                9) List initialization.
               10) Type aliases.
               11) Variadic templates.
               12) Lambda expressions.
               13) `noexcept`.
               14) `alignof` and `alignas`.
               15) Multithreaded memory model.
               16) Range for.
               17) Static assertions.
                *) etc.

             - C++14
               1) Variable templates.
               2) Polymorphic lambdas.
               3) Relaxed restrictions on `constexpr` functions.
               4) Binary literals.
               5) Return type deduction for functions.
               6) Aggregate initialization for classes with brace-or-equal initializers.
               *) etc.

             - C++17
               1) Fold-expressions.
               2) Compile-time if `constexpr`.
               3) Inline variables.
               4) Structured bindings.
               5) Simplified nested namespaces.
               6) new order of evaluation rules.
               7) Lambda capture of `*this`.
               8) `constexpr` lambda.
               *) etc.

             - C++20
               1) Three-way comparison operator `<=>` and `operator==() = default`.
               2) Designated initializers.
               3) Init-statements and initializers in range-for.
               4) `char8_t`.
               5) `consteval`.
               6) Further relaxed `constexpr`.
               7) Signed integers are 2's complement.
               8) Aggregate initialization using parentheses.
               9) Array new can deduce array size.
               *) etc.
               
[X][5]  (*3) Describe the difference between dynamic (run-time) and static (compile-time) type checking.
             - Dynamic type checking
               An error in the dynamic type checking system will spit out errors at run-time.
             - Static type checking
               An error in the static type checking system will spit out errors at compile-time.
               
[X][6]  (*1) List the major components of the C++ standard library.
             - Containers.
             - Algorithms.
             - Iterators.
             - Strings.
             - Regex.
             - Streams.
             - Locales.
             - Numerics.
             - Utilities.
             - Multithreading.
             - etc.
             
[X][7]  (*1) List five libraries that you would have liked to be part of the standard.
             - None. I'm a minimalist.
             - Libraries I'm interested in:
             1) Boost.
             2) Qt.
             3) Curlpp.
             4) OpenCV
             5) SFML.
             6) SDL.
             7) OpenGL.
             
[X][8]  (*1) List three (or more) advantages from having a library as part of the standard.
             1) The library is guaranteed to be robust.
             2) The library is safe to use.
             3) The library will be well documented.
             
[X][9]  (*3) List 20 major real-world C++ applications/companies that utilize C++.
              1) Adobe systems.
              2) Amazon.com.
              3) Apple.
              4) Bloomberg.
              5) EMule.
              6) Facebook.
              7) Google.
              8) Hewlett-Packard.
              9) IBM.
             10) Intel.
             11) Microsoft.
             12) Mozilla Firefox.
             13) MySQL.
             14) Paypal.
             15) Southwest airlines.
             16) StarCraft.
             17) Utorrent.
             18) Winamp.
             19) World of Warcraft.
             20) YouTube.
             
[X][10] (*2) From §1.3 pick five suggestions that to you looks most likely to help improve your programming style.
             1) Use `unique_ptr` to utilize RAII.
             2) Use move semantics to avoid copying large objects.
             3) Avoid nake `new` and `delete`.
             4) Prefer the STL over homemade code.
             5) Use templates to utilize static type safety.
             
[X][11] (*2) Make a "top-ten list" of helpful design and programming rules.
              1) Get rid of magic numbers.
              2) Factor out duplicate code.
              3) Use auto to enhance readabilily to the next person reading your code; not just for the compiler.
              4) Represent ideas and concepts directly through code; functions/classes/enumerations.
              5) Don't over-abstract.
              6) Avoid mutual dependencies between classes.
              7) Prefer solutions that can be statically type-checked.
              8) Low-level code is not necessarily more efficient; always measure.
              9) If data has an invariant, encapsulate it.
             10) Express ideas simply.

-----------------------------
X.3 A Tour of C++: The Basics
-----------------------------
[ ][1] (*1) What does a compiler do? What does a linker do?
            - A compiler translates source code into object files.
            - A linker take the object files generated by the compiler and links them together.
            
[X][2] (*2) Get the "Hello, world!" program (§2.2.1) to run. This is not an exercise in programming. It is an exercise to test your use of your
            edit-compile-link-execute tool chain.
[ ][3] (*1) List three (or more) C++ compilers.
            - GCC.
            - Clang.
            - MSVC.
            - Intel C++.
            
[X][4] (*1) Write out a `bool`, a `char`, an `int`, a `double`, and a `std::string`.
            ```
            #include <string> std::string

            int main() {
                bool        b{true};
                char        c{'c'};
                int         i{42};
                double      d{3.14};
                std::string s{"hello"};

                std::cout << "bool       b:\t" << b << '\n';
                std::cout << "char       c:\t" << c << '\n';
                std::cout << "int        i:\t" << i << '\n';
                std::cout << "double     d:\t" << d << '\n';
                std::cout << "std:string s:\t" << s << '\n';

                return 0;
            }
            ```

[X][5] (*1) Read in a `bool`, a `char`, an `int`, a `double`, and a `std::string`.
            ```
            #include <string> std::string

            int main() {
                bool        b; std::cin >> b;
                char        c; std::cin >> c;
                int         i; std::cin >> i;
                double      d; std::cin >> d;
                std::string s; std::cin >> s;

                return 0;
            }
            ```
[X][6] (*2) What is an invariant and what good might it do?
            - In invarient is any logical rule that must be obeyed throughout the execution of a program that can be communicated to a human, but not a compiler.
            - I would assert that an invarient can also be communicated to the compiler by utilizing static assertions when constructing objects,
              calling functions, etc.

-----------------------------------------
X.4 A Tour of C++: Abstraction Mechanisms
-----------------------------------------
[X][1] (*2) Give five examples of concrete types that are built-in types in C++. Give five examples of concrete types that are not built-in types in C++.
            - Built-in concrete types:
            1) `bool`.
            2) `char`.
            3) `int`.
            4) `float`.
            5) `double`.

            - Not built-in concrete types:
            1) `std::array`.
            2) `std::vector`.
            3) `std::deque`.
            4) `std::list`.
            5) `std::forward_list`.
            6) `std::string`.

--------------------------------------------
X.5 A Tour of C++: Containers and Algorithms
--------------------------------------------
[X][1] (*1) List five standard-library containers.
            1) `std::set`.
            2) `std::map`.
            3) `std::multiset`.
            4) `std::multimap`.
            5) `std::unordered_set`.
            6) `std::unordered_map`.
            7) `std::unordered_multiset`.
            8) `std::unordered_multimap`.
            
[X][2] (*1) List five standard-library algorithms.
            1) `std::all_of`.
            2) `std::any_of`.
            3) `std::none_of`.
            4) `std::for_each`.
            5) `std::for_each_n`.
            
[X][3] (*1) List five standard-library headers.
            1) `#include <array>`.
            2) `#include <vector>`.
            3) `#include <deque>`.
            4) `#include <list>`.
            5) `#include <forward_list>`.
            6) `#include <string>`.
            
[X][4] (*1) Write a program that reads a name (a `std::string`) and an age (an `int`) from the standard input stream `std::cin`. Then output a message
            including the name and age to the standard output stream `std::cout`.
            ```
            #include <iostream> std::cout
            #include <string>   std::string

            int main() {
                std::string name;
                std::cin >> name;

                size_t age;
                std::cin >> age;

                std::cout << "Your name is "
                          << name
                          << ", and you are "
                          << age
                          << " years old.\n";

                return 0;
            }
            ```

[X][5] (*1) Redo §X.5[5], storing several (name,age) pairs in a class. Doing the reading and writing using your own >> and << operators.
            ```
            #include <iostream> // std::cout
            #include <string>   // std::string

            class Person {
                std::string name;
                size_t      age;

                friend std::ostream& operator<<(std::ostream& o, const Person& p);
                friend std::istream& operator>>(std::istream& i,  Person& p);
            };

            std::ostream& operator<<(std::ostream& o, const Person& p) {
                o << "Your name is "
                  << p.name
                  << ", and you are "
                  << p.age
                  << " years old.";

                return o;
            }

            std::istream& operator>>(std::istream& i, Person& p) {
                i >> p.name >> p.age;
                return i;
            }

            int main() {
                Person p;
                std::cin  >> p;
                std::cout << p << '\n';
            
                return 0;
            }
            ```
            
[X][6] (*2) Initialize a `std::vector<int>` with the elements 5, 9, −1, 200, and 0. Print it. Sort is, and print it again.
            ```
            #include <iostream> std::cout
            #include <vector>   std::vector

            int main() {
                std::vector<int> v{5, 9, -1, 200, 0};
    
                for (auto i : v)
                    std::cout << i << ' ';
                std::cout << '\n';

                std::sort(v.begin(), v.end());

                for (auto i : v)
                    std::cout << i << ' ';
                std::cout << '\n';

                return 0;
            }
            ```
            
[X][7] (*1) Repeat §X.5[7] with a `std::vector<string>` initialized with "Kant", "Plato", "Aristotle", "Kierkegard", and "Hume".
            ```
            #include <iostream> std::cout
            #include <string>   std::string
            #include <vector>   std::vector

            int main() {
                std::vector<std::string> v{"Kant", "Plato", "Aristotle", "Kierkegard", "Hume"};
    
                for (auto s : v)
                    std::cout << s << ' ';
                std::cout << '\n';

                std::sort(v.begin(), v.end());

                for (auto s : v)
                    std::cout << s << ' ';
                std::cout << '\n';

                return 0;
            }
            ```
            
[X][8] (*1) Open a file for writing (as an `std::ofstream`) and write a few hundred integers to it, and open the file of integers for reading
            (as an `std::ifstream`) and read it.
            ```
            #include <iostream> // std::cout
            #include <fstream>  // std::ifstream, std::ofstream

            int main() {
                std::ofstream fo;
                fo.open("temp.txt");
                for (size_t i{0}; i < 300; ++i)
                    fo << i << ' ';
                fo << '\n';
                fo.close();
    
                std::ifstream fi;
                fi.open("temp.txt");
                size_t i{};
                while (fi >> i)
                    std::cout << i << ' ';
                std::cout << i << '\n';
                fi.close();

                return 0;
            }
            ```

--------------------------------------------
X.6 A Tour of C++: Concurrency and Utilities
--------------------------------------------
[X][1] (*1) Write a program with two treads: one that writes hello every second and one that writes world! every second.
            ```
            #include <iostream> // std::cout
            #include <thread>   // std::thread

            void print_hello() {
                std::cout << "Hello, ";
                std::this_thread::sleep_for(std::chrono::seconds(1));
            }

            void print_world() {
                std::cout << "world!\n";
                std::this_thread::sleep_for(std::chrono::seconds(1));
            }

            int main() {
                for (size_t i{0}; i < 5; ++i) {
                    std::thread t0{print_hello};
                    std::thread t1{print_world};
            
                    t0.join();
                    t1.join();
                }
    
                return 0;
            }
            ```
            
[X][2] (*2) Time a loop. Write out the time in milliseconds. Do this for the default setting of your compiler and for a setting using an optimizer
            (e.g., −O2 or "release").
            Be careful not to have the optimizer eliminate your whole loop as dead code because you did not use a result.
            - `clang++ -O0 -Wall -Wextra -std=c++17 -stdlib=libc++ -lc++abi -o a.out main.cpp; ./a.out`: 174564
            - `clang++ -O1 -Wall -Wextra -std=c++17 -stdlib=libc++ -lc++abi -o a.out main.cpp; ./a.out`:  28365
            - `clang++ -O2 -Wall -Wextra -std=c++17 -stdlib=libc++ -lc++abi -o a.out main.cpp; ./a.out`:  29138
            - `clang++ -O3 -Wall -Wextra -std=c++17 -stdlib=libc++ -lc++abi -o a.out main.cpp; ./a.out`:  28311
            ```
            #include <chrono>   // std::chrono::high_resolution_clock
            #include <iostream> // std::cout

            int main() {

                std::chrono::high_resolution_clock::time_point t1 = std::chrono::high_resolution_clock::now();
                for (size_t i{0}; i < 100000000; ++i) asm("");
                std::chrono::high_resolution_clock::time_point t2 = std::chrono::high_resolution_clock::now();
                auto duration = std::chrono::duration_cast<std::chrono::microseconds>(t2-t1).count();

                std::cout << duration << std::endl;
    
                return 0;
            }
            ```
            
[X][3] (*2) Repeat the histogram drawing example from §5.6.3 for a normal_distribution and 30 rows.
            ```
            #include <iostream> // std::cout
            #include <random>   // std::default_random_engine, std::normal_distribution
            #include <vector>   // std::vector

            using my_engine       = std::default_random_engine;
            using my_distribution = std::normal_distribution<double>;

            class rand_int {
            public:
                rand_int(double low, double high) : dist{low,high}
                { }
                double operator()() { return dist(engine); }

            private:
                my_engine       engine;
                my_distribution dist;
            };

            int main() {
                rand_int rand{15.0, 5.0};
                std::vector<size_t> histogram(30);
    
    
                for (size_t i{0}; i < 200; ++i) {
                    double tmp{rand()};
                    if (0.0 <= tmp && tmp <= 29)
                        ++histogram[static_cast<int>(tmp)];
                }
    
                for (size_t i{0}; i < histogram.size(); ++i) {
                    std::cout << i << '\t';
                    for (size_t j{0}; j < histogram[i]; ++j)
                        std::cout << '*';
                    std::cout << '\n';
                }
    
                return 0;
            }
            ```
            
[X][4] (*1) Use a regex to find all decimal numbers in a file.
            ```
            #include <cstdlib>   // std::strtol

            #include <algorithm> // std::copy_if
            #include <iostream>  // std::cout
            #include <iterator>  // std::back_inserter
            #include <fstream>   // std::ifstream
            #include <sstream>   // std::istringstream, std::istream_iterator
            #include <string>    // std::string
            #include <vector>    // std:vector

            class find_decimal_in_file {
            public:
            find_decimal_in_file(const std::string& file_path) : file{file_path}
            { }

            void parse_file() {
                if (file) {
                    std::string line, file_text;

                    // Fill string with file contents verbatim.
                    while (file_text += (!line.empty()) ? (line + '\n') : (""), getline(file, line));

                    if (!file_text.empty()) {
                        std::vector<std::string> tokens{split(file_text)};
                        std::copy_if(tokens.begin(), tokens.end(), std::back_inserter(decimal_matches), is_valid_number);
                    }
                }
            }

            void print_matches() {
                for (const auto& decimal_match : decimal_matches)
                    std::cout << decimal_match << '\n';
            }

            ~find_decimal_in_file() {
                file.close();
            }

            private:
                std::ifstream            file;
                std::vector<std::string> decimal_matches;

                std::vector<std::string> split(const std::string& str) {
                    std::istringstream iss(str);
                    return { std::istream_iterator<std::string>{iss}, std::istream_iterator<std::string>{} };
                }

                static bool is_valid_number(const std::string& str) {
                    char* end;
                    std::strtol(str.data(), &end, 10);
                    return *end == '\0';
                }
            };

            int main() {
                find_decimal_in_file fd{"/home/i/temp.txt"};
                fd.parse_file();
                fd.print_matches();

            return 0;
            }
            ```

--------------------------
X.7 Types and Declarations
--------------------------
[X][1]  (*2) Get the "Hello, world!" program (§2.2.1) to run. This is not an exercise in programming. It is an exercise to test your use of your
             edit-compile-link-execute tool chain.
[X][2]  (*1) Write a program that prints signed if a plain `char` are signed on your implementation and unsigned otherwise.
             ```
             #include <iostream> // std::cout

             int main() {
                 char c{-1}; // Will not compile if `char` is unsigned.
                 std::cout << "signed\n";
                 return 0;
             }
             ```
             
[X][3]  (*1) Find 5 different C++ constructs for which the meaning is undefined (§6.1). (*1.5) Find 5 different C++ constructs for which the meaning is
             implementation-defined (§6.1).
             - Undefined behavior:
             1) Memory access out-of-bounds.
             2) Signed integer overflow.
             3) Null pointer dereference.
             4) Access to an object through a pointer of a different type.
             5) And infinite loop without side-effects.
             *) etc.

             - Implementation-defined behavior:
             1) `#pragma`
             2) Algorithms for producing the standard random number distributions.
             3) Alignment.
             4) Bits in a byte.
             5) Definition of `NULL`.
             *) etc.
             
[X][4]  (*1) Find 10 different examples of nonportable C++ code.
              1) Windows-only programs.
              2) Linux-only programs.
              3) Not keeping platform-specific code separate from reusable code (`#ifdef`, `#ifndef`).
              4) Assuming the size of a pointer if four bytes.
              5) Assuming the size of an `int` is four bytes.
              6) Assuming the size of a `char` is four bytes.
              7) Assuming that a pointer can be copied into an `int` (apparent in older software).
              8) Any code that makes assumptions about the largest possible memory address.
              9) Abiding to implementation-defined behavior of a specific compiler.
             10) Not testing code on multiple compilers.
             
[X][5]  (*1) For each declaration in §6.3, do the following: If the declaration is not a definition, write a definition for it. If the declaration is a
             definition, write a declaration for it that is not also a definition.
             ```
             #include <iostream>  // std::cout
             #include <string>    // std::string
             #include <vector>    // std::vectorusing namespace std;

             int main() {
                 char        ch_def;
                 extern char ch_dec;

                 extern int error_number_dec;
                 int        error_number_def{0};

                 const double        pi_def{3.14};
                 extern const double pi_dec;

                 const char*        name_def{"Njal"};
                 extern const char* name_dec;

                 const char*        season_def[]{"spring", "summer", "fall", "winter"};
                 extern const char* season_dec[];

                 std::string        str_def;
                 extern std::string str_dec;

                 std::vector<std::string>        people_def{name_def, "Skarphedin", "Gunnar"};
                 extern std::vector<std::string> people_dec;

                 auto        count_def{1};
                 // extern auto count_dec; // Illegal.

                 return 0;
             }
             ```
             
[X][6]  (*1) Write a program that prints the sizes of the fundamental types, a few pointer types, and a few enumerations of your choice. Use the sizeof operator.
             ```
             #include <iostream> // std::cout
             #include <string>   // std::string

             template<typename T>
             void print_size(std::string s) {
                 std::cout << "sizeof(" << s << "): " << sizeof(T) << '\n';
             }

             enum ENUM {};

             enum class ENUM_CLASS_BOOL  : bool  {};
             enum class ENUM_CLASS_CHAR  : char  {};
             enum class ENUM_CLASS_SHORT : short {};
             enum class ENUM_CLASS_INT   : int   {};
             
             int main() {
                 print_size<bool  >("bool");
                 print_size<char  >("char");
                 print_size<short >("short");
                 print_size<int   >("int");
                 print_size<float >("float");
                 print_size<double>("double");

                 print_size<bool*  >("bool*");
                 print_size<char*  >("char*");
                 print_size<short* >("short*");
                 print_size<int*   >("int*");
                 print_size<float* >("float*");
                 print_size<double*>("double*");

                 print_size<ENUM >("ENUM");
                 print_size<ENUM*>("ENUM*");
    
                 print_size<ENUM_CLASS_BOOL >("ENUM_CLASS_BOOL");
                 print_size<ENUM_CLASS_CHAR >("ENUM_CLASS_CHAR");
                 print_size<ENUM_CLASS_SHORT>("ENUM_CLASS_SHORT");
                 print_size<ENUM_CLASS_INT  >("ENUM_CLASS_INT");

                 print_size<ENUM_CLASS_BOOL >("ENUM_CLASS_BOOL*");
                 print_size<ENUM_CLASS_CHAR >("ENUM_CLASS_CHAR*");
                 print_size<ENUM_CLASS_SHORT>("ENUM_CLASS_SHORT*");
                 print_size<ENUM_CLASS_INT  >("ENUM_CLASS_INT*");

                 return 0;
             }
             ```
             
[X][7]  (*1) Write a program that prints out the letters 'a'..'z' and the digits '0'..'9' and their integer values. Do the same for other printable characters.
             Do the same again but use hexadecimal notation.
             ```
             #include <iostream> // std::cout

             void print_alpha(char start, char end) {
                 for (; start <= end; ++start)
                     std::cout << start << " == " << static_cast<int>(start) << '\n';
                 std::cout << '\n';
             }

             void print_alpha_hex(char start, char end) {
                 for (; start <= end; ++start)
                     std::cout << start << " == " << std::hex << std::showbase << static_cast<int>(start) << '\n';
                 std::cout << '\n';
             }

             int main() {
                 print_alpha('a', 'z');
                 print_alpha('0', '9');
                 print_alpha_hex('a', 'z');
                 print_alpha_hex('0', '9');

                 return 0;
             }
             ```
             
[X][8]  (*2) What, on your system, are the largest and the smallest values of the following types: `bool`, `char`, `short`, `int`, `long`, `long long`,
             `float`, `double`, `long double`, `unsigned` and `unsigned long`.
             ```
             #include <iostream> std::cout
             #include <limits>   std::numeric_limits
             #include <string>   std::string

             template<typename T>
             void print_limits(std::string s) {
                 std::cout << s << " min: " << std::numeric_limits<T>::min() << '\n';
                 std::cout << s << " max: " << std::numeric_limits<T>::max() << "\n\n";
             }

             int main() {
                 print_limits<bool         >("bool");
                 print_limits<char         >("char");
                 print_limits<short        >("short");
                 print_limits<int          >("int");
                 print_limits<long         >("long");
                 print_limits<long long    >("long long");
                 print_limits<float        >("float");
                 print_limits<double       >("double");
                 print_limits<long double  >("long double");
                 print_limits<unsigned     >("unsigned");
                 print_limits<unsigned long>("unsigned long");

                 return 0;
             }
             ```
             bool min: 0
             bool max: 1

             char min: \200
             char max: ^?

             short min: -32768
             short max: 32767

             int min: -2147483648
             int max: 2147483647

             long min: -9223372036854775808
             long max: 9223372036854775807

             long long min: -9223372036854775808
             long long max: 9223372036854775807

             float min: 1.17549e-38
             float max: 3.40282e+38

             double min: 2.22507e-308
             double max: 1.79769e+308

             long double min: 3.3621e-4932
             long double max: 1.18973e+4932

             unsigned min: 0
             unsigned max: 4294967295

             unsigned long min: 0
             unsigned long max: 18446744073709551615
             
[X][9]  (*1) What are the sizes (in number of chars) of the types mentioned in §X.7[8]?
             sizeof(bool): 1
             sizeof(char): 1
             sizeof(short): 2
             sizeof(int): 4
             sizeof(long): 8
             sizeof(long long): 8
             sizeof(float): 4
             sizeof(double): 8
             sizeof(long double): 16
             sizeof(unsigned): 4
             sizeof(unsigned long): 8
             
[X][10] (*1) What are the alignments (in number of chars) of the types mentioned in §X.7[8]?
             std::alignment_of<bool>(): 1
             std::alignment_of<char>(): 1
             std::alignment_of<short>(): 2
             std::alignment_of<int>(): 4
             std::alignment_of<long>(): 8
             std::alignment_of<long long>(): 8
             std::alignment_of<float>(): 4
             std::alignment_of<double>(): 8
             std::alignment_of<long double>(): 16
             std::alignment_of<unsigned>(): 4
             std::alignment_of<unsigned long>(): 8
             
[X][11] (*1) What is the longest local name you can use in a C++ program on your system? What is the longest external name you can use in a C++ program on
             your system?
             - According to `https://stackoverflow.com/questions/6007568/what-is-max-length-for-an-c-c-identifier-on-common-build-systems` there is no
               limit (as well as with `clang`).
             
[X][12] (*1) Write a loop that prints out the values 4, 5, 9, 17, 12 without using an array or a `std::vector`.
             ```
             // 0 0 1 0 0 ==  4
             // 0 0 1 0 1 ==  5
             // 0 1 0 0 1 ==  9
             // 1 0 0 0 1 == 17
             // 0 1 1 0 0 == 12

             #include <iostream> // std::cout
             #include <bitset>   // std::bitset

             int main() {
                 std::bitset<25>         bs{"0110010001010010010100100"};
                 const std::bitset<25> mask{"0000000000000000000011111"};
    
                 for (size_t i{0}; i < 5; ++i)
                     std::cout << (mask & (bs >> (i*5))) << '\n';

                 return 0;
             }
             ```

------------------------------------
X.8 Pointers, Arrays, and References
------------------------------------
[X][1]  (*1) Write declarations for the following: a pointer to a character, an array of 10 integers, a reference to an array of 10 integers, a pointer
             to an array of character strings, a pointer to a pointer to a character, a constant integer, a pointer to a constant integer, and a constant
             pointer to an integer. Initialize each one.
             ```
             // main.cpp
             
             #include <iostream>  // std::cout

             #include "declarations.hpp"

             int main() {    
                 return 0;
             }
             ```
             
             ```
             // declarations.hpp

             extern char*      char_pointer;
             extern char*      pointer_to_array_char_strings[];
             extern char**     char_pointer_to_pointer;
             extern const int  const_int;
             extern const int* pointer_to_const_int;
             extern int* const const_pointer_to_int;
             extern int        int_array[10];
             extern int        (&int_array_ref)[10];
             ```

             ```
             // definitions.cpp

             #include "declarations.hpp"

             char*      char_pointer                   {};
             char*      pointer_to_array_char_strings[]{};
             char**     char_pointer_to_pointer        {};
             const int  const_int                      {};
             const int* pointer_to_const_int           {};
             int* const const_pointer_to_int           {};
             int        int_array[10]                  {};
             int        (&int_array_ref)[10]           {int_array};
             ```
             
[X][2]  (*1) On your system, what are the restrictions on pointer types: `char*`, `int*`, and `void*`? For example, may an `int*` have an odd value?
             - They all appear to behave the same. Each pointer has an alignment of 8 bytes (because I'm using a machine with 64 bit pointers).
               Thus, unlike a `char` which has an alignment of 1, a `char*` has an alignment of 8.
             
[X][3]  (*1) Use an alias (using) to define the types `unsigned char`, `const unsigned char`, `int*`, `char**`, pointer to array of char, array of 7 pointers
             to int, pointer to an array of 7 pointers to int, and array of 8 arrays of 7 pointers to int.
             ```
             int main() {
                 using uc         = unsigned char;
                 using cuc        = const unsigned char;
                 using ip         = int*;
                 using cpp        = char**;
                 using pac        = char (*)[];
                 using a_7_ip     = int* [7];
                 using pa_7_ip    = int* (*)[7];
                 using a_8_a_7_pi = int* [8][7];
                 return 0;
             }
             ```
             
[X][4]  (*1) Given two char* pointing into an array, find and output the number of characters between the two pointed-to characters.
             ```
             #include <iostream>  // std::cout

             int main() {
                 char carr[10]{'a','b','c','d','e','f','g','h','i','j'};
                 char* cp0{&carr[0]};
                 char* cp1{&carr[1]};

                 size_t count{};
                 if (cp0 == cp1)
                     count = 0;
                 else {
                     while (cp0++ != cp1)
                         ++count;
                     --count;
                 }
        
                 std::cout << count << '\n';
    
                 return 0;
             }
             ```
             
[X][5]  (*1) Given two int* pointing into an array, find and output the number of ints between the two pointed-to ints.
             ```
             #include <iostream> // std::cout

             int main() {
                 int iarr[10]{0,1,2,3,4,5,6,7,8,9};
                 int* ip0{&iarr[1]};
                 int* ip1{&iarr[8]};

                 size_t count{};
                 if (ip0 == ip1)
                     count = 0;
                 else {
                     while (ip0++ != ip1)
                         ++count;
                     --count;
                 }
        
                 std::cout << count << '\n';
    
                 return 0;
             }
             ```
             
[X][6]  (*2) What happens when you read and write beyond the bounds of an array. Do a few experiments involving a global array of ints , a local array of
             ints, an array of ints allocated by new, and a member array of ints. Try reading and writing just beyond the end and far beyond the end.
             Try the same for just before and far before the beginning. See what happens for different optimizer levels. Then try hard never to do
             out-of-range access by mistake.
             - What happens? I have no idea what just happened. All I know is that I crashed something and had to restart my computer.
             
[X][7]  (*1) Write a function that swaps (exchanges the values of) two integers. Use int* as the argument type. Write another swap function using
             int& as the argument type.
             ```
             #include <iostream> // std::cout

             void swapper_with_pointer(int* p0, int* p1) {
             int tmp{*p0};
                 *p0 = *p1;
                 *p1 = tmp;
             }

             void swapper_with_reference(int& p0, int& p1) {
                 int tmp{p0};
                 p0 = p1;
                 p1 = tmp;
             }

             int main() {
                 int i  = 1;
                 int ii = 2;

                 std::cout << i  << '\n';
                 std::cout << ii << "\n\n";

                 swapper_with_pointer(&i, &ii);

                 std::cout << i  << '\n';
                 std::cout << ii << "\n\n";

                 swapper_with_reference(i, ii);

                 std::cout << i  << '\n';
                 std::cout << ii << "\n\n";

                 return 0;
             }
             ```
             
[X][8]  (*1) What is the size of the array str in the following example: `char str[]{"a short string"};` What is the length of the
             `std::string str{"a short string"}?
             - Both have a length of 14 (note that both also have an inherent null terminator as well).
             
[X][9]  (*1) Define functions `f(char)`, `g(char&)`, and `h(const char&)`. Call them with the arguments 'a', 49, 3300, c, uc, and sc, where c is a char,
             uc is an unsigned char, and sc is a signed char. Which calls are legal? Which calls cause the compiler to introduce a temporary variable?
             ```
             #include <iostream> // std::cout

             void f(char c) {
                 std::cout << "in `void f(char c)`\n";
             }

             void g(char& c) {
                 std::cout << "in `void g(char& c)`\n";
             }

             void h(const char& c) {
                 std::cout << "in `void h(const char& c)`\n";
             }

             int main() {
                 char          c  {};
                 unsigned char uc {};
                 signed char   sc {};

                 f('a');  // Introduces temporary.
                 f(49);   // Introduces temporary.
                 f(3300); // Implicit conversion/Introduces temporary.
                 f(c);    // Introduces temporary.
                 f(uc);   // Introduces temporary.
                 f(sc);   // Introduces temporary.

                 // g('a');  // Illegal.
                 // g(49);   // Illegal.
                 // g(3300); // Illegal.
                 g(c);
                 // g(uc); // Illegal.
                 // g(sc); // Illegal.

                 h('a');
                 h(49);
                 h(3300); // Implicit conversion.
                 h(c);
                 h(uc);
                 h(sc);

                 return 0;
             }
             ```
             
[X][10] (*1) Define an array of `std::string` in which the strings contain the names of the months. Print those strings. Pass the array to a function that
             prints those strings.
             ```
             #include <array>    // std::array
             #include <iostream> // std::cout
             #include <string>   // std::string

             void printer(const std::array<std::string, 12> &arr ) {
                 for (const auto& str : arr)
                     std::cout << str << '\n';
                 std::cout << '\n';
             }

             int main() {
                 const std::array<std::string, 12> arr { "January", "February", "March", "April",
                                                         "May", "June", "July", "August",
                                                         "Septemeber", "October", "November", "December" };
                                            
                 for (const auto& str : arr)
                     std::cout << str << '\n';
                 std::cout << '\n';

                 printer(arr);
    
                 return 0;
             }
             ```
             
[X][11] (*2) Read a sequence of words from input. Use Quit as a word that terminates the input. Print the words in the order they were entered. Don’t
             print a word twice. Modify the program to sort the words before printing them.
             ```
             #include <iostream> // std::cout
             #include <set>      // std::set
             #include <string>   // std::string

             int main() {
                 std::set<std::string> set{};
                      
                 std::string tmp{};
                 while (std::cin >> tmp) {
                     if (tmp == "Quit")
                         break;
                     set.insert(tmp);
                 }

                 for (const auto& str : set)
                     std::cout << str << '\n';

                 return 0;
             }
             ```
             
[X][12] (*2) Write a function that counts the number of occurrences of a pair of letters in a `std::string` and the same in a zero-terminated array of
             char (a C-style string). For example, the pair "ab" appears twice in "xabaacbaxabb".
             ```
             #include <iostream> // std::cout
             #include <string>   // std::string

             size_t count_occurances(const std::string& pair, const std::string& str) {

                 std::string tmp   {str};
                 size_t      count {};
                 size_t      finder{tmp.find(pair)};

                 while (finder != std::string::npos) {
                     ++count;
                     
                     tmp = std::string(tmp, finder);
                     tmp.erase(0, pair.length());

                     finder = tmp.find(pair);
                 }

                 return count;
             }

             int main() {
                 const std::string s_pair{"ab"};
                 const std::string s_str {"xabaacbaxabb"};

                 const char c_pair[]{"ab"};
                 const char c_str []{"xabaacbaxabbab"};

                 std::cout << count_occurances(s_pair, s_str) << '\n';
                 std::cout << count_occurances(c_pair, c_str) << '\n';

                 return 0;
             }
             ```
             
[X][13] (*2) Run some tests to see if your compiler really generates equivalent code for iteration using pointers and iteration using indexing (§7.4.1).
             If different degrees of optimization can be requested, see if and how that affects the quality of the generated code.
             - The code generated is not identical; no matter which optimization level is chosen.
             
             ```
             int main() {
                 int iarr[10]{0,1,2,3,4,5,6,7,8,9};
    
                 for (int i{iarr[0]}; i < iarr[9]; ++i)
                     asm("");
        
                 for (int* i{&iarr[0]}; i != &iarr[10]; ++i)
                     asm("");
        
                 return 0;
             }
             ```

----------------------------------------
X.9 Structures, Unions, and Enumerations
----------------------------------------
[X][1] (*1) Define a struct with a member of each of the types `bool`, `char`, `int`, `long`, `double`, and `long double`. Order the members so as to get
            the largest size of the struct and the smallest size of the struct.
            ```
            #include <iostream> // std::cout

            struct S0 {
                _char         c;
                _bool         b;
                _int          i;
                _long         l;
                _double       d;
                _long double ld;
            };

            struct S1 {
                _char         c;
                _long double ld;
                _double       d;
                _long         l;
                _int          i;
                _bool         b;
            };

            int main() {
                std::cout << sizeof(S0) << '\n';
                std::cout << sizeof(S1) << '\n';
        
                return 0;
            }
            ```
            
[X][2] (*1) Define a table of the names of months of the year and the number of days in each month. Write out that table.
            Do this twice; once using an array of char for the names and an array for the number of days and once using an array of structures,
            with each structure holding the name of a month and the number of days in it.
            ```
            #include <cstdlib> // size_t

            struct calendar0 {
                const char* _months[12]{ "January", "February", "March", "April",
                                         "May", "June", "July", "August",
                                         "September", "October", "November", "December" };

                const size_t _days_in_month[12]{31,28,31,30,31,30,31,31,30,31,30,31};
            };

            struct month {
                const char* _month_name;
                size_t      _month_days;
            };

            struct calendar1 {
            month _months[12] { {"January",31},{"February",28},{"March",31},{"April",30},
                                {"May",31},{"June",30},{"July",31},{"August",31},
                                {"September",30},{"October",31},{"November",30},{"December",31} };
            };

            int main() {
                return 0;
            }
            ```
            
[X][3] (*1) Find an example where it would make sense to use a name in its own initializer.
            - When initializing a `void` pointer to itself: `void* p{&p};`
            
[X][4] (*1) Define a struct Date to keep track of dates. Provide functions that read Dates from input, write Dates to output, and initialize a Date with a date.
            ```
            #include <iostream> // std::cout // std::cin

            struct Date {
                size_t _day, _month, _year;
                friend std::ostream&  operator<<(std::ostream& o, const Date d);
                friend std::istream& operator>>(std::istream& i, Date& d);
            };

            std::ostream&  operator<<(std::ostream& o, const Date d) {
                o << d._day << '/' << d._month << '/' << d._year;
                return o;
            }

            std::istream& operator>>(std::istream& i, Date& d) {
                i >> d._day >> d._month >> d._year;
                return i;
            }

            int main() {
                Date date0{};
                Date date1{};
    
                std::cin  >> date0;
                std::cout << date0 << '\n';
    
                date1 = date0;
                std::cout << date1 << '\n';
    
                return 0;
            }
            ```
            
[X][5] (*2) Implement class called Season with enumerators spring, summer, autumn, and winter. Define operators ++ and −− for Season. Define input (>>)
            and output (<<) operations for Season, providing string values. Provide a way to control the mapping between Season values and their
            string representations.
            ```
            #include <iostream> // std::cout // std::cin

            class season {
            public:
                season() : seas{-1}
                { }
            
                season(const int s) {
                    assert(0 <= s && s <= 3);
                    seas = static_cast<season::which>(s);
                }
            
                season(const std::string str) {
                    if (str == "Spring" || str == "spring")
                        seas = SPRING;
                    else if (str == "Summer" || str == "spring")
                        seas = SUMMER;
                    else if (str == "Autumn" || str == "autumn")
                        seas = AUTUMN;
                    else if (str == "Winter" || str == "winter")
                        seas = WINTER;
                    else
                        throw("Invalid construction of a season");
                }
            
                season& operator++() {
                    assert(seas != -1);
                    inc();
                    return *this;
                }
            
                season operator++(int) {
                    assert(seas != -1);
                    season tmp{*this};
                    inc();
                    return tmp;
                }
            
                season& operator--() {
                    assert(seas != -1);
                    dec();
                    return *this;
                }
            
                season operator--(int) {
                    assert(seas != -1);
                    season tmp{*this};
                    dec();
                    return tmp;
                }
            
                friend std::ostream& operator<<(std::ostream& o, const season& s);
                friend std::istream& operator>>(std::istream& i, season& s);
            
            private:
                enum which : int {SPRING, SUMMER, AUTUMN, WINTER};
                which seas{};
            
                void inc() {
                    switch(seas) {
                        case 0:
                            seas = SUMMER;
                            break;
                        case 1:
                            seas = AUTUMN;
                            break;
                        case 2:
                            seas = WINTER;
                            break;
                        case 3:
                            seas = SPRING;
                            break;
                    }
                }
            
                void dec() {
                    switch(seas) {
                        case 0:
                            seas = WINTER;
                            break;
                        case 1:
                            seas = SPRING;
                            break;
                        case 2:
                            seas = SUMMER;
                            break;
                        case 3:
                            seas = AUTUMN;
                            break;
                    }
                }
            };
            
            std::ostream& operator<<(std::ostream& o, const season& s) {
                switch(s.seas) {
                    case -1:
                        o << "No season set";
                        break;
                    case 0:
                        o << "Spring";
                        break;
                    case 1:
                        o << "Summer";
                        break;
                    case 2:
                        o << "Autumn";
                        break;
                    case 3:
                        o << "Winter";
                        break;
                    default:
                        throw("Unexpected error");
                }
                
                return o;
            }
            
            std::istream& operator>>(std::istream& i, season& s) {
                int tmp{};
                i >> tmp;
                assert(0 <= tmp && tmp <= 3);
                s.seas = static_cast<season::which>(tmp);
                
                return i;
            }
            
            int main() {
                
                {
                    static season s;
                    std::cout << s << '\n';
                    s = 0;
                    std::cout << s << '\n';
                
                    ++s; std::cout << s << '\n';
                    ++s; std::cout << s << '\n';
                    ++s; std::cout << s << '\n';
                    ++s; std::cout << s << "\n\n";
                }
            
                {
                    static season s;
                    std::cout << s << '\n';
                    s = 0;
                    std::cout << s << '\n';
                
                    s++; std::cout << s << '\n';
                    s++; std::cout << s << '\n';
                    s++; std::cout << s << '\n';
                    s++; std::cout << s << "\n\n";
                }
                
                {
                    static season s;
                    std::cout << s << '\n';
                    s = 0;
                    std::cout << s << '\n';
                
                    --s; std::cout << s << '\n';
                    --s; std::cout << s << '\n';
                    --s; std::cout << s << '\n';
                    --s; std::cout << s << "\n\n";
                }
                
                {
                    static season s;
                    std::cout << s << '\n';
                    s = 0;
                    std::cout << s << '\n';
                
                    s--; std::cout << s << '\n';
                    s--; std::cout << s << '\n';
                    s--; std::cout << s << '\n';
                    s--; std::cout << s << "\n\n";
                }
            
                {
                    static season s;
                    std::cout << s << '\n';
            
                    std::cin  >> s;
                    std::cout << s << '\n';
                    std::cin  >> s;
                    std::cout << s << '\n';
                }
                
                return 0;
            }
            ```

---------------
X.10 Statements
---------------
[X][1] (*1) Rewrite the following for-statement as an equivalent while-statement.
            Rewrite it to use a pointer as the controlled variable, that is, so that the test is of the form: *p=='?'.
            Rewrite it to use a range-for.
```
for (i=0; i!=max_length; i++)
    if (input_line[i] == '?')
        quest_count++;
```

            ```
            size_t i          {};
            size_t quest_count{};
            size_t max_length {10};
        
            char input_line[10]{'!','?','!','!','!','!','?','!','?','?'};
            
            while (i != max_length) {
                if (input_line[i] == '?')
                    quest_count++;
                ++i;
            }
            ```

            ```
            size_t quest_count{};
            size_t max_length {10};
        
            char input_line[10]{'!','?','!','!','!','!','?','!','?','?'};
            
            char* cp{&input_line[0]};
            while (cp != input_line+max_length) {
                if (*cp == '?')
                    quest_count++;
                ++cp;
            }
            ```

            ```
            char input_line[10]{'!','?','!','!','!','!','?','!','?','?'};
    
            for (const auto& c : input_line)
                if (c == '?')
                    quest_count++;
            ```

[X][2] (*1) See how your compiler reacts to these errors. Devise more simple errors and see how the compiler reacts.
```
void f(int a, int b)
{
    if (a = 3) // ...
    if (a&077 == 0) // ...
    a := b+1;
}
```

[X][3] (*1) What does the following example do? Why would anyone write something like that? No, this is not recommended as good style.
            - What does it do? Well it doesn't do anything because it doesn't compile.
              I suppose someone would write something like this if they don't like having their code compile.
              Or it could be for obfuscation reasons, or because the person wants to look clever, or maybe I'm just not wise enough to know exactly why.
              Just learned that this technique is actually called "loop unrolling"; the objective is to speed up the program by reducing the loop iterations;
              utilizes a space-time-tradeoff to achieve these results. Pretty cool.
            
```
void send(int* to, int* from, int count)
// Duff ’s device. Helpful comment deliberately deleted.
{
    int n = (count+7)/8;
    switch (count%8) {
           case 0: do { *to++ = *from++;
           case 7: *to++ = *from++;
           case 6: *to++ = *from++;
           case 5: *to++ = *from++;
           case 4: *to++ = *from++;
           case 3: *to++ = *from++;
           case 2: *to++ = *from++;
           case 1: *to++ = *from++;
           } while (−−n>0);
    }
}
```

[X][4] (*2) Write a function atoui(const char*) that takes a C-style string containing digits and returns the corresponding unsigned. For example,
            atoui("123") is 123.
            ```
            #include <cmath>    // pow
            #include <cstring>  // strlen
            #include <iostream> // std::cout
            
            int jd_atoui(const char* str) {
                const size_t  len{strlen(str)};
                unsigned      ret{};
                unsigned      tmp{};
                for (size_t i{0}; i < len; ++i)
                    if (0 <= (j = str[i] - '0') && (str[i] - '0') <= 9)
                        ret += j*pow(10,len-1-i);
                return ret;
            }
            
            int main() {
                std::cout << jd_atoui("123") << '\n';
                return 0;
            }
            ```
            
[X][5] (*2) Write a function uitoa(unsigned i, char b[]) that creates a string representation of i in b and returns b.
            ```
            #include <cmath>     // pow
            #include <cstring>   // strlen
            #include <algorithm> // std::swap
            #include <iostream>  // std::cout
            
            int jd_atoui(const char* str) {
                const size_t  len{strlen(str)};
                unsigned      ret{};
                unsigned      tmp{};
                for (size_t i{0}; i < len; ++i)
                    if (0 <= (tmp = str[i] - '0') && (str[i] - '0') <= 9)
                        ret += tmp*pow(10,len-1-i);
                return ret;
            }
            
            char* jd_uitoa(unsigned ui, char str[]) {
                size_t       j  {};
                char         tmp{};
                while (ui != 0) {
                    tmp = ui%10;
                    ui/=10;
                    str[j++] = tmp + '0';
                }
                str[strlen(str)] = '\0';
            
                const size_t len{strlen(str)};
                size_t       start{};
                size_t       end{len-1};
                while(start < end) {
                    std::swap(*(str+start), *(str+end));
                    ++start;
                    --end;
                }
                
                return str;
            }
            
            int main() {
                const char* str{"123"};
                int         num{jd_atoui(str)};
                
                char carr[4]{};
                jd_uitoa(num,carr);
                std::cout << carr << '\n';
                       
                return 0;
            }
            ```
            
[X][6] (*2) Write a program that strips comments out of a C++ program. That is, read from cin, remove both // comments and /* */ comments,
            and write the result to `std::cout`. Do not worry about making the layout of the output look nice (that would be another, and much harder, exercise).
            Do not worry about incorrect programs. Beware of //, /*, and */ in comments, strings, and character constants.
            ```
            #include <iostream> // std::cout
            #include <fstream>  // std::filebuf, std::fstream
            
            void print_file(const std::fstream& f) {
                std::cout << "---------------------------------" << "\n";
                std::cout << f.rdbuf();
                std::cout << "---------------------------------" << "\n\n";
            }
            
            int main() {
                std::fstream f;
                
                f.open("temp.cpp");
                print_file(f);
                f.close();
            
                f.open("temp.cpp");
                char c;
                while (f.get(c)) {
                    if (c == '/') {
                        if (f.peek() == '/') {
                            f.unget();
                            while (f.peek() != '\n')
                                f << "X";
                        }
                        else if (f.peek() == '*') {
                            f.unget();
                            f << "XX";
                            while (f.peek()) {
                                f << "X";
                                if (f.peek() == '*') {
                                    f << "X";
                                    if (f.peek() == '/') {
                                        f << "X";
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                f.close();
            
                f.open("temp.cpp");
                print_file(f);
                f.close();
                
                return 0;
            }
            ```

----------------
X.11 Expressions
----------------
[X][1]  (*1) Fully parenthesize the following expressions:
```
                           |  int f(int i,int j) {return int{i+j};}
                           |
                           |  int main() {
                           |      int  a{},b{},c{},d{},i{},x{};
                           |      int  aa[4][2]{}, *bb{&b}, *dd{&d};
a=b+c * d << 2 & 8         |      (a = (((b + (c * d)) << 2) & 8));
a & 077 != 3               |      ((a & 077) != 3);
a == b || a == c && c < 5  |      ((a == b) || ((a == c) && (c < 5)));
c = x != 0                 |      (c = (x != 0));
0 <= i < 7                 |      (0 <= i < 7);
f(1,2)+3                   |      (f(1,2))+3;
a = - 1 + + b -- - 5       |      (a = (-1 + +b-- -5));
a = b == c ++              |      (a = (b == (c++)));
a=b=c=0                    |      (a=b=c=0);
a[4][2] *= * b?c: * d * 2  |      ((aa[3][1]) *= *(bb) ? c : (*(dd) * 2));
a-b,c=d                    |      (a-b),(c=d);
                           |      return 0;
                           |  }
```
        
[X][2] (*1) Write a table of values for the bitwise logical operations (§11.1.1) for all possible combinations of 0 and 1 operands.
        ```
        #include <iostream> // printf
        #include <vector>   // std::vector

        // -------------------------------
        // |  a  |  b  |  &  |  |  |  ^  |
        // |  0  |  0  |     |     |     |
        // |  1  |  0  |     |     |     |
        // |  0  |  1  |     |     |     |
        // |  1  |  1  |     |     |     |
        // -------------------------------
        
        void print_table(const std::vector<bool>& v) {
            printf("-------------------------------\n"
                   "|  a  |  b  |  &  |  |  |  ^  |\n"
                   "|  0  |  0  |  %d  |  %d  |  %d  |\n"
                   "|  1  |  0  |  %d  |  %d  |  %d  |\n"
                   "|  0  |  1  |  %d  |  %d  |  %d  |\n"
                   "|  1  |  1  |  %d  |  %d  |  %d  |\n"
                   "---------------------------------\n",
                   v[0],v[ 1],v[ 2],
                   v[3],v[ 4],v[ 5],
                   v[6],v[ 7],v[ 8],
                   v[9],v[10],v[11]);
        }

        int main() {
            std::vector<bool> v;
            v.push_back(0&0); v.push_back(0|0); v.push_back(0^0);
            v.push_back(1&0); v.push_back(1|0); v.push_back(1^0);
            v.push_back(0&1); v.push_back(0|1); v.push_back(0^1);
            v.push_back(1&1); v.push_back(1|1); v.push_back(1^1);
        
            print_table(v);
            
            return 0;
        }
        ```
        
[X][3] (*2) Write an expression for which the order of evaluation is undefined.
            ```
            i = ++i + i++;
            ```
        
[X][4] (*1) What happens if you divide by zero on your system? What happens in case of overflow and underflow?
            - Notified of undefined behavior by the compiler.
            - Not notified of underflow/overflow by the compiler.
             
[X][5] (*1) Fully parenthesize the following expressions:
```
            |  struct Obj { int m{}; int* mm{&m}; };
            |
            |  int main() {
            |      int   a[3]{0,1,2};
            |      int* aa   {a};
            |      int   b   {};
            |      int* bb   {&b};
            |      int  i0   {};
            |      int  i1   {};
            |      int  i2   {};
            |      int* cc[3]{&i0,&i1,&i2};
            |      Obj   o   {};
            |      Obj* oo   {&o};
*p++        |      (*(bb++));
*--p        |      (*(--bb));
++a--       |      ((++aa)--);  // The result is a prvalue copy of the original value of the operand.
(int*)p->m  |      ((int*)(oo->m));
*p.m        |      (*(o.mm));
*a[i]       |      (*(cc[i0])); // Some cool tricks can probably come of this.
            |      return 0;
            |  }
```

[X][6] (*2) Implement and test these functions: `strlen()`, which returns the length of a C-style string; `strcpy()`, which copies a C-style string into
            another; and `strcmp()`, which compares two C-style strings. Consider what the argument types and return types ought to be.
            ```
            #include <iostream> // std::cout

            size_t jd_strlen(const char* str) {
                size_t count{};
                while( (*(str++)) ) ++count;
                return count;
            }

            char* jd_strcpy(char* dest, const char* src) {
                while( ((*(dest++)) = (*(src++))) );
                return dest;
            }

            // This is prolly super inefficient lulz.
            int jd_strcmp(const char* str1, const char* str2) {
                int ret{};
                while(*str1 != '\0') {
                    if(*str1 < *str2)
                        return -1;
                    else if ( (*(str2++)) < (*(str1++)) )
                        return  1;
                }
                if (*str2 == '\0')
                    return 0;
                return -1;
            }

            int main() {
                {
                    const char* str{"hello"};
                    std::cout << jd_strlen(str) << '\n';
                }
                
                {
                    const char* str  {"hello"};
                    char        arr[6]{};
                    jd_strcpy(arr, str);
                    std::cout << arr << '\n';
                }
            
                {
                    const char* str1  {"zello"};
                    const char* str2  {"hello"};
                    std::cout << jd_strcmp(str1,str2) << '\n';
                }
    
                return 0;
            }
            ```

[X][7] (*2) Write a function `cat()` that takes two C-style string arguments and returns a string that is the concatenation of the arguments. Use new to
            find store for the result.
            ```
            #include <cstring>  // strlen
            #include <iostream> // std::cout

            // Again prolly not that efficient, but gets the job done.
            char* cat(const char* str1, const char* str2) {
                size_t combined_length{ strlen(str1) + strlen(str2) };
                char*  ret            { new char[combined_length+1] };
                strcpy(ret, str1);
                strcpy(ret+strlen(str1), str2);
                ret[combined_length] = '\0';
                return ret;
            }

            int main() {
                const char* str1{"hello"};
                const char* str2{" world!"};
                const char* str3{ cat(str1, str2) };

                std::cout << str3 << '\n';
                delete[] str3;
    
                return 0;
            }
            ```
             
[X][8] (*2) Write a function `rev()` that takes a C-style string argument and reverses the characters in it. That is, after `rev(p)` the last character of
            `p` will be the first, etc.
            ```
            #include <cstring>  // strlen
            #include <iostream> // std::cout

            char* rev(char carr[]) {
                size_t beg{0};
                size_t end{strlen(carr)-1};

                while(beg < end) {
                    char tmp{carr[beg]};
                    carr[beg] = carr[end];
                    carr[end] = tmp;
                    ++beg;
                    --end;
                }

                return carr;
            }

            int main() {
                char carr[]{"hello"};
                std::cout << carr << '\n';
                std::cout << rev(carr) << '\n';
                return 0;
            }
            ```

----------------------
X.12 Select Operations
----------------------
[X][1] (*1) Copy all even non-zero elements of an `int[]` into a `std::vector<int>`. Use a pointer and ++ for the traversal.
            ```
            #include <iostream> // std::cout
            #include <vector>   // std::vector

            int main() {
                std::vector<int> vec;
                const int iarr[10]{0,1,2,3,0,5,0,7,8,9};
                for (const int* iter{iarr}; iter < std::end(iarr); ++iter)
                    if (*iter != 0)
                        vec.push_back(*iter);

                for (const auto i : vec)
                    std::cout << i << '\n';

                return 0;
            }
            ```
             
[X][2] (*2) Allocate so much memory using new that `std::bad_alloc` is thrown. Report how much memory was allocated and how much time it took. Do this twice:
            once not writing to the allocated memory and once writing to each element.
	    - It took allocating 3221225472 bytes before the error was thrown. Interesting to note that this was the first time I've seen the swap indicator
	      in action; not sure why it won't go back to `0`. This took about 10 seconds or so. Writing and not writing had the same effect.
            ```
            #include <iostream> // std::cout
            #include <vector>   // std::vector

            int main() {
                for (size_t i{0}; i < 1024*1024*1024; ++i) {
                    std::cout << "Allocating   " << i*1024*1024*1024 << '\n';
                    int* j = new int[i*1024*1024*1024]{};
                    delete[] j;
                    std::cout << "Deallocating " << i*1024*1024*1024 << '\n';
                }

                return 0;
            }
            ```
            
[X][3] (*2) Write a simple loop calculating a sum of elements (like `std::accumulate()`). Write it in a dozen or more ways using for-statements, range-for
            statements, the `for_each()` algorithm, using indices, pointers, and iterators, using "plain code", function objects, and lambdas, and using
            different element types. See if you can find any performance differences between the different versions.
            ```
            #include <algorithm>  // std::for_each
            #include <chrono>     // std::chrono::high_resolution_clock
            #include <functional> // std::function
            #include <iostream>   // std::cout
            #include <vector>     // std::vector
            
            using namespace std::chrono;
            
            #define MEASURE_START(current_test)                                         \
                {                                                                       \
                    std::cout << "---STARTING MEASUREMENT---"       << '\n';            \
                    std::cout << "Currently testing: " current_test << '\n';            \
                    high_resolution_clock::time_point t1{high_resolution_clock::now()}; \
                    
            #define MEASURE_STOP                                                        \
                    high_resolution_clock::time_point t2{high_resolution_clock::now()}; \
                    auto duration{duration_cast<microseconds>(t2-t1).count()};          \
                    std::cout << "Duration: " << duration     << '\n';                  \
                    std::cout << "---STOPPING MEASUREMENT---" << "\n\n";                \
                }                                                                       \
            
            #define FOR_STATEMENT_INDICES_CODE                      \
                static std::vector<T> vec;                          \
                                                                    \
                for (size_t i{0}; i < 1000000; ++i) {               \
                    if (sizeof(T) == 1)                             \
                        vec.push_back(i % 256);                     \
                    else                                            \
                        vec.push_back(i);                           \
                }                                                   \
                                                                    \
                size_t total{};                                     \
                for (size_t i{0}; i < vec.size(); ++i)              \
                    total += vec[i];                                \
                std::cout << "Total calculated: " << total << '\n'; \
            
            #define FOR_STATEMENT_POINTERS_CODE                             \
                static std::vector<T> vec;                                  \
                                                                            \
                for (size_t i{0}; i < 1000000; ++i) {                       \
                    if (sizeof(T) == 1)                                     \
                        vec.push_back(i % 256);                             \
                    else                                                    \
                        vec.push_back(i);                                   \
                }                                                           \
                                                                            \
                size_t total{};                                             \
                for (T* iter{&vec[0]}; iter != &vec[vec.size()]; ++iter)    \
                    total += *iter;                                         \
                std::cout << "Total calculated: " << total << '\n';         \
            
            #define FOR_STATEMENT_ITERATORS_CODE                            \
                static std::vector<T> vec;                                  \
                                                                            \
                for (size_t i{0}; i < 1000000; ++i) {                       \
                    if (sizeof(T) == 1)                                     \
                        vec.push_back(i % 256);                             \
                    else                                                    \
                        vec.push_back(i);                                   \
                }                                                           \
                                                                            \
                size_t total{};                                             \
                for (auto iter{vec.cbegin()}; iter != vec.cend(); ++iter)   \
                    total += *iter;                                         \
                std::cout << "Total calculated: " << total << '\n';         \
            
            #define FOR_EACH_CODE                                   \
                static std::vector<T> vec;                          \
                                                                    \
                for (size_t i{0}; i < 1000000; ++i) {               \
                    if (sizeof(T) == 1)                             \
                        vec.push_back(i % 256);                     \
                    else                                            \
                        vec.push_back(i);                           \
                }                                                   \
                                                                    \
                size_t total{};                                     \
                for (const auto& val : vec)                         \
                    total += val;                                   \
                std::cout << "Total calculated: " << total << '\n'; \
            
            #define RANGE_FOR_CODE                                                  \
                static std::vector<T> vec;                                          \
                                                                                    \
                for (size_t i{0}; i < 1000000; ++i) {                               \
                    if (sizeof(T) == 1)                                             \
                        vec.push_back(i % 256);                                     \
                    else                                                            \
                        vec.push_back(i);                                           \
                }                                                                   \
                                                                                    \
                size_t total{};                                                     \
                std::for_each(vec.cbegin(), vec.cend(), [&total](const T& val){     \
                        total += val;                                               \
                    });                                                             \
                std::cout << "Total calculated: " << total << '\n';                 \
            
            template<typename T>
            void for_statement_indices_plain_code() {
                FOR_STATEMENT_INDICES_CODE
            }
            
            template<typename T>
            void for_statement_pointers_plain_code() {
                FOR_STATEMENT_POINTERS_CODE
            }
            
            template<typename T>
            void for_statement_iterators_plain_code() {
                FOR_STATEMENT_ITERATORS_CODE
            }
            
            template<typename T>
            auto for_statement_indices_function_object{[]() {
                    FOR_STATEMENT_INDICES_CODE
                }
            };
            
            template<typename T>
            auto for_statement_pointers_function_object{[]() {
                    FOR_STATEMENT_POINTERS_CODE
                }
            };
            
            template<typename T>
            auto for_statement_iterators_function_object{[]() {
                    FOR_STATEMENT_ITERATORS_CODE
                }
            };
            
            template<typename T>
            std::function<void()> for_statement_indices_function_wrapper{for_statement_indices_function_object<T>};
            template<typename T>
            std::function<void()> for_statement_pointers_function_wrapper{for_statement_pointers_function_object<T>};
            template<typename T>
            std::function<void()> for_statement_iterators_function_wrapper{for_statement_iterators_function_object<T>};
            
            template<typename T>
            void range_for_plain_code() {
                RANGE_FOR_CODE
            }
            
            template<typename T>
            auto range_for_function_object{[]() {
                    RANGE_FOR_CODE
                }
            };
            
            template<typename T>
            std::function<void()> range_for_function_wrapper{range_for_function_object<T>};
            
            template<typename T>
            void for_each_plain_code() {
                FOR_EACH_CODE
            }
            
            template<typename T>
            auto for_each_function_object{[]() {
                    FOR_EACH_CODE
                }
            };
            
            template<typename T>
            std::function<void()> for_each_function_wrapper{for_each_function_object<T>};
            
            int main() {
                MEASURE_START("for_statement_indices_plain_code<char>")
                for_statement_indices_plain_code<char>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_indices_plain_code<int>")
                for_statement_indices_plain_code<int>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_indices_plain_code<size_t>")
                for_statement_indices_plain_code<size_t>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_pointers_plain_code<char>")
                for_statement_pointers_plain_code<char>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_pointers_plain_code<int>")
                for_statement_pointers_plain_code<int>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_pointers_plain_code<size_t>")
                for_statement_pointers_plain_code<size_t>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_iterators_plain_code<char>")
                for_statement_iterators_plain_code<char>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_iterators_plain_code<int>")
                for_statement_iterators_plain_code<int>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_iterators_plain_code<size_t>")
                for_statement_iterators_plain_code<size_t>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_indices_function_object<char>")
                for_statement_indices_function_object<char>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_indices_function_object<int>")
                for_statement_indices_function_object<int>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_indices_function_object<size_t>")
                for_statement_indices_function_object<size_t>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_pointers_function_object<char>")
                for_statement_pointers_function_object<char>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_pointers_function_object<int>")
                for_statement_pointers_function_object<int>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_pointers_function_object<size_t>")
                for_statement_pointers_function_object<size_t>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_iterators_function_object<char>")
                for_statement_iterators_function_object<char>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_iterators_function_object<int>")
                for_statement_iterators_function_object<int>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_iterators_function_object<size_t>")
                for_statement_iterators_function_object<size_t>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_indices_function_wrapper<char>")
                for_statement_indices_function_wrapper<char>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_indices_function_wrapper<int>")
                for_statement_indices_function_wrapper<int>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_indices_function_wrapper<size_t>")
                for_statement_indices_function_wrapper<size_t>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_pointers_function_wrapper<char>")
                for_statement_pointers_function_wrapper<char>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_pointers_function_wrapper<int>")
                for_statement_pointers_function_wrapper<int>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_pointers_function_wrapper<size_t>")
                for_statement_pointers_function_wrapper<size_t>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_iterators_function_wrapper<char>")
                for_statement_iterators_function_wrapper<char>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_iterators_function_wrapper<int>")
                for_statement_iterators_function_wrapper<int>();
                MEASURE_STOP
            
                MEASURE_START("for_statement_iterators_function_wrapper<size_t>")
                for_statement_iterators_function_wrapper<size_t>();
                MEASURE_STOP
            
                MEASURE_START("range_for_plain_code<char>")
                range_for_plain_code<char>();
                MEASURE_STOP
            
                MEASURE_START("range_for_plain_code<int>")
                range_for_plain_code<int>();
                MEASURE_STOP
            
                MEASURE_START("range_for_plain_code<size_t>")
                range_for_plain_code<size_t>();
                MEASURE_STOP
            
                MEASURE_START("range_for_function_object<char>")
                range_for_function_object<char>();
                MEASURE_STOP
            
                MEASURE_START("range_for_function_object<int>")
                range_for_function_object<int>();
                MEASURE_STOP
            
                MEASURE_START("range_for_function_object<size_t>")
                range_for_function_object<size_t>();
                MEASURE_STOP
            
                MEASURE_START("range_for_function_wrapper<char>")
                range_for_function_wrapper<char>();
                MEASURE_STOP
            
                MEASURE_START("range_for_function_wrapper<int>")
                range_for_function_wrapper<int>();
                MEASURE_STOP
            
                MEASURE_START("range_for_function_wrapper<size_t>")
                range_for_function_wrapper<size_t>();
                MEASURE_STOP
            
                MEASURE_START("for_each_plain_code<char>")
                for_each_plain_code<char>();
                MEASURE_STOP
            
                MEASURE_START("for_each_plain_code<int>")
                for_each_plain_code<int>();
                MEASURE_STOP
            
                MEASURE_START("for_each_plain_code<size_t>")
                for_each_plain_code<size_t>();
                MEASURE_STOP
            
                MEASURE_START("for_each_function_object<char>")
                for_each_function_object<char>();
                MEASURE_STOP
            
                MEASURE_START("for_each_function_object<int>")
                for_each_function_object<int>();
                MEASURE_STOP
            
                MEASURE_START("for_each_function_object<size_t>")
                for_each_function_object<size_t>();
                MEASURE_STOP
            
                MEASURE_START("for_each_function_wrapper<char>")
                for_each_function_wrapper<char>();
                MEASURE_STOP
            
                MEASURE_START("for_each_function_wrapper<int>")
                for_each_function_wrapper<int>();
                MEASURE_STOP
            
                MEASURE_START("for_each_function_wrapper<size_t>")
                for_each_function_wrapper<size_t>();
                MEASURE_STOP
                    
                return 0;
            }
            ```
            
[X][4] (*2) Define an `apply(v,f)` that applies a function `f` to each element of `v` assumed to be a `vector<Shape*>`. Test `apply()` with a a variety of
            functions, function objects, and lambdas. Note that by capturing variables from a lambda or storing values in a function object, you can call `Shape`
            functions that takes arguments without having to have `f()` take explicit arguments.
            ```
	    #include <chrono>     // std::chrono::high_resolution_clock
            #include <functional> // std::function
            #include <iostream>   // std::cout
            #include <vector>     // std::vector
                        
            using namespace std::chrono;
                        
            #define MEASURE_START(current_test)                                     \
                {                                                                   \
                std::cout << "---STARTING MEASUREMENT---"       << '\n';            \
                std::cout << "Currently testing: " current_test << '\n';            \
                high_resolution_clock::time_point t1{high_resolution_clock::now()}; \
                                
            #define MEASURE_STOP                                                    \
                high_resolution_clock::time_point t2{high_resolution_clock::now()}; \
                auto duration{duration_cast<microseconds>(t2-t1).count()};          \
                std::cout << "Duration: " << duration     << '\n';                  \
                std::cout << "---STOPPING MEASUREMENT---" << "\n\n";                \
                }                                                                   \
            
            struct Shape {
                size_t sides;
            };
            
            void add_size(Shape s) {
                s.sides += 1;
            }
            
            void apply(std::vector<Shape*> vec) {
                for (auto s : vec)
                    add_size(*s);
            }
            
            template<typename F>
            void apply(std::vector<Shape*> vec, F f) {
                for (auto s : vec)
                    f(*s);
            }
            
            auto add_size_function_object{ [](Shape s){s.sides += 1;} };
            std::function<void(Shape s)> add_size_function_wrapper{add_size};
            
            int main() {
                Shape s0{0},s1{1},s2{2},s3{3},s4{4};
                std::vector<Shape*> vec{&s0,&s1,&s2,&s3,&s4};
                
                auto print_sides{ [](std::vector<Shape*>& vec) {
                        for (const auto& s : vec)
                            std::cout << s->sides << ' ';
                        std::cout << '\n';
                    }
                };
            
                MEASURE_START("apply(vec)")
                apply(vec);
                print_sides(vec);
                MEASURE_STOP
            
                MEASURE_START("apply(vec, add_size_function_object)")
                apply(vec, add_size_function_object);
                print_sides(vec);
                MEASURE_STOP
            
                MEASURE_START("apply(vec, add_size_function_wrapper)")
                apply(vec, add_size_function_wrapper);
                print_sides(vec);
                MEASURE_STOP
            
                MEASURE_START("apply(vec, [](Shape s){s.sides += 1;})")
                apply(vec, [](Shape s){s.sides += 1;});
                print_sides(vec);
                MEASURE_STOP

                return 0;
            }
            ```

--------------
X.13 Functions
--------------
[X][1]  (*1) Write declarations for the following: a function taking arguments of type pointer to character and reference to integer and returning no
             value; a pointer to such a function; a function taking such a pointer as an argument; and a function returning such a pointer. Write the
             definition of a function that takes such a pointer as an argument and returns its argument as the return value.
             ```
             using funct_pointer = void(*)(char*, int&);

             void f0(char* pc, int& ri);
             void f1(void(pf)(char*, int&));
             void (*f2(char*, int&))();
             void (*f3(char*, int&))(void(pf)(char*, int&));
             funct_pointer f4(funct_pointer pf) { return pf; }
             
             int main() {
                 void (*pf0)(char*, int&);
                 return 0;
             }
             ```
             
[X][2]  (*1) What does the following mean? What would it be good for? using rfiii = int(&)(int, int);
             - It is a type alias to a reference of a function that contains two `int` parameters and returns an `int`.
	       The only thing that I can think of is ff you want to make sure that an identifier used as an indirection to a function is never allowed to get
	       passed around to other functions.
             
[X][3]  (*1) Write a program like "Hello, world!" that takes a name as a command-line argument and writes "Hello, name!". Modify this program to take
             any number of names as arguments and to say hello to each.
             ```
             #include <iostream> // std::cout
             #include <string>   // std::string
             
             void hello(std::string str) {
                 std::cout << "Hello, " << str << '\n';
             }
             
             int main(int argc, char* argv[]) {
                 for (int i{1}; i < argc; ++i)
                     hello(argv[i]);
                 
                 return 0;
             }
             ```

[X][4]  (*1) Write a program that reads an arbitrary number (possibly limited to some maximum number) of files whose names are given as command-line
             arguments and writes them one after another on `std::cout`. You might know this program as called `cat`.
             ```
	     #include <exception> // std::exception
             #include <fstream>   // std::fstream
             #include <iostream>  // std::cout
             
             int main(int argc, char* argv[]) {
                 try {
                     std::fstream f;
                     if (argc > 4)
                         throw std::exception{};
                     for (int i{1}; i < argc; ++i) {
                         f.open(argv[i]);
                         if (!f)
                             throw std::exception{};
                         std::cout << argv[i] << ":\n" << f.rdbuf() << "\n\n";
                         f.close();
                     }
             
                 } catch (...) {
                     std::cout << "You have committed erroneous behavior." << '\n';
                 }
                 
                 return 0;
             }
             ```
             
[X][5]  (*2) Convert a small C program to C++. Modify the header files to declare all functions called and to declare the type of every argument. Where
             possible, replace `#defines` with `enum`, `const`, `constexpr`, or `inline`. Remove `extern` declarations from .cpp files and if necessary
	     convert all function definitions to C++ function definition syntax. Replace calls of `malloc()` and `free()` with `new` and `delete`.
	     Remove unnecessary casts.
             ```
	     /* yes - output a string repeatedly until killed
             Copyright (C) 1991-1997, 1999-2004, 2007-2010 Free Software Foundation, Inc.

             This program is free software: you can redistribute it and/or modify
             it under the terms of the GNU General Public License as published by
   	     the Free Software Foundation, either version 3 of the License, or
   	     (at your option) any later version.

   	     This program is distributed in the hope that it will be useful,
   	     but WITHOUT ANY WARRANTY; without even the implied warranty of
   	     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   	     GNU General Public License for more details.

   	     You should have received a copy of the GNU General Public License
   	     along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

	     /* David MacKenzie <djm@gnu.ai.mit.edu> */

             #include <cstring>  // std::strcmp
             #include <csignal>  // std::signal
             #include <iostream> // std::cout
             
             
             static const std::string program_name{"yes"};
             static const std::string author      {"John DeBord"};
             
             enum class STATUS{ FAILURE, SUCCESS };
             
             void usage (STATUS status) {
                 if (status != STATUS::SUCCESS)
                     std::cerr << "Try `"   << program_name << " --help` for more information.\n";
                 else {
                     std::cout << "Usage: " << program_name << " [STRING]\n"
                               << "Repeatedly output a line with all specified STRING(s), or `y`.\n";
                     exit (static_cast<int>(status));
                 }
             }
             
             void signal_handler(int signum) {
                 std::cout << "Interrupt signal (" << signum << ") received.\n"
                           << "Exiting program.\n";
                 exit (signum);
             }
             
             int main (int argc, char* argv[]) {
                 if (argc != 2)
                     usage (STATUS::SUCCESS);
             
                 std::signal(SIGINT, signal_handler);
             
                 std::string option{argv[1]};
             
                 while (true)
                     std::cout << option << '\n';

                 return 0;
             }
             ```
	     
[X][6]  (*2) Implement a sorting algorithm.
             ```
	     #include <algorithm> // std::swap
             #include <iostream>  // std::cout
            
             int main() {
                 static int arr[10]{4,8,2,3,1,5,9,7,0,6};
                 
                 bool is_sorted{false};
                 while(!is_sorted) {
                     for (size_t i{0}; i < 9; ++i) {
                         is_sorted = true;
                         if (arr[i] < arr[i+1])
                             continue;
                         else {
                             std::swap(arr[i], arr[i+1]);
                             is_sorted = false;
                             break;
                         }
                     }
                 }
             
                 for (const auto& i : arr)
                     std::cout << i << ' ';
                 std::cout << '\n';
                 
                 return 0;
             }
             ```
             
[X][7]  (*2) Consider:
```
struct Tnode {
    std::string word;
    Tnode*      left;
    Tnode*      right;
};
```
             Write a function for entering new words into a tree of `Tnodes`. Write a function to write out a tree of `Tnodes`. Write a function to write out
             a tree of `Tnodes` with the words in alphabetical order.
             ```
	     #include <iostream> // std::cout
             #include <string>   // std::string
             
             struct Tnode {
                 std::string word;
                 Tnode*      left;
                 Tnode*      right;
             };
             
             Tnode* insert_node(Tnode* node, std::string str) {
                 Tnode* tmp = new Tnode{str,nullptr,nullptr};
                 
                 while (true) {
                     if (node->word < str) {
                         if (node->right == nullptr) {
                             node->right = tmp;
                             return tmp;
                         }
                         node = node->right;
                         
                         if (node->left  == nullptr) {
                             node->left = tmp;
                             return tmp;
                         }
                         node = node->left;
                     }
                 }
             }
             
             void pre_order(Tnode* root) {
                 if(root == nullptr)
                     return;
                 std::cout << root->word << '\n';
                 pre_order(root->left);
                 pre_order(root->right);
             }
             
             void in_order(Tnode* root) {
                 if(root == nullptr)
                     return;
                 in_order(root->left);
                 std::cout << root->word << '\n';
                 in_order(root->right);
             }
             
             void post_order(Tnode* root) {
                 if(root == nullptr)
                     return;
                 post_order(root->left);
                 post_order(root->right);
                 std::cout << root->word << '\n';
             }
             
             int main() {
                 Tnode root{"hello",nullptr,nullptr};
                 Tnode* n0{insert_node(&root, "world!")};
                 pre_order(&root);  std::cout << '\n';
                 in_order(&root);   std::cout << '\n';
                 post_order(&root); std::cout << '\n';
                 
                 return 0;
             }
             ```
             
[X][8]  (*2) Write a function to invert a two-dimensional array.
             ```
	     #include <cmath>    // std::abs
             #include <iostream> // std::cout

             void invert_array(int arr[][5]) {
                 int arr2[5][5]{};
                 int tmp;
                 for (int i{0}; i < 5; ++i) {
                     for (int j{0}; j < 5; ++j) {
                         // arr2[i][j] = arr[std::abs(i-4)][std::abs(j-4)];
                         // arr2[i][j] = arr[~(i-4)+1][~(j-4)+1];
                         arr2[i][j] = arr[-(i-4)][-(j-4)];
                     }
                 }
             
                 for (size_t i{0}; i < 5; ++i) {
                     for (size_t j{0}; j < 5; ++j) {
                         std::cout << arr2[i][j] << '\t';
                     }
                     std::cout << '\n';
                 }
                 std::cout << '\n';
             }
             
             int main() {
                 int arr[5][5]{ { 0, 1, 2, 3, 4},
                                { 5, 6, 7, 8, 9},
                                {10,11,12,13,14},
                                {15,16,17,18,19},
                                {20,21,22,23,24} };
             
                 for (size_t i{0}; i < 5; ++i) {
                     for (size_t j{0}; j < 5; ++j) {
                         std::cout << arr[i][j] << '\t';
                     }
                     std::cout << '\n';
                 }
                 std::cout << '\n';
             
                 invert_array(arr);
                 
                 return 0;
             }
             ```
             
[X][9]  (*2) Write an encryption program that reads from `std::cin` and writes the encoded characters to `std::cout`. You might use this simple
             encryption scheme: the encrypted form of a character `c` is `cˆkey[i]`, where key is a string passed as a command-line argument. The program
	     uses the characters in key in a cyclic manner until all the input has been read. Re-encrypting encoded text with the same key produces the
	     original text. If no key (or a null string) is passed, then no encryption is done.
             ```
	     #include <cstring>   // std::strlen
             #include <exception> // std::exception
             #include <iostream>  // std::cout
             #include <string>    // std::string
             
             std::string encrypt(std::string str, const std::string key) {
                 auto key_iter{key.cbegin()};
                 std::string ret(str.size(), ' ');
                 for (size_t i{0}; i < str.size(); ++i)
                     ret[i] = str[i]^*key_iter++;
                 return ret;
             }
             
             std::string decrypt(std::string str, const std::string key) {
                 return encrypt(str, key);
             }
             
             int main(int argc, char* argv[]) {
                 try {
                     if (argc != 2)
                         throw std::exception{};
                     if (std::strlen(argv[1]) < 8)
                         throw std::exception{};
                     
                     const std::string key{argv[1]};
             
                     std::cout << "Enter the message to encrypt: " << '\n';
                     std::string message;
                     std::cin >> message;
             
                     if (message.size() < 8)
                         throw std::exception{};
             
                     message = encrypt(message, key);
                     std::cout << "The encrypted message: " << message << '\n';
             
                     message = decrypt(message, key);
                     std::cout << "The decrypted message: " << message << '\n';
                 }
                 catch (...) {
                     std::cout << "Erroneous behavior encountered.\n";
                 }
                 
                 return 0;
             }
             ```
             
[X][10] (*2) Without using copy and paste, implement and test TEA (the Tiny Encryption Algorithm). D.J. Wheeler and R.M. Needham: TEA, a tiny
             encryption algorithm. Lecture Notes in Computer Science 1008: 363366. http://143.53.36.235:8080/tea.htm.
             ```
             #include <cstdint>  // uint32_t
             #include <iostream> // std::cout
             
             void encrypt(uint32_t v[2], uint32_t k[4]) {
                 uint32_t v0{v[0]}, v1{v[1]};
                 uint32_t k0{k[0]}, k1{k[1]}, k2{k[2]}, k3{k[3]};
                 uint32_t delta{0x9E3779B9};
                 uint32_t sum  {};
             
                 for (size_t i{0}; i < 32; ++i) {
                     sum += delta;
                     v0 += ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1);
                     v1 += ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3);
                 }
                 v[0] = v0; v[1] = v1;
             }
             
             void decrypt(uint32_t v[2], uint32_t k[4]) {
                 uint32_t v0{v[0]}, v1{v[1]};
                 uint32_t k0{k[0]}, k1{k[1]}, k2{k[2]}, k3{k[3]};
                 uint32_t delta{0x9E3779B9};
                 uint32_t sum  {0xC6EF3720};
                 
                 for (size_t i{0}; i < 32; ++i) {
                     v1 -= ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3);
                     v0 -= ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1);
                     sum -= delta;
                 }
                 v[0] = v0; v[1] = v1;
             }
             
             int main() {
                 uint32_t v[2]{48839483,1343419};
                 uint32_t k[4]{18384934,3848923,3242525,54285822};
                 
                 for (size_t i{0}; i < 10000; ++i) {
                     encrypt(v,k);
                 }
                 std::cout << v[0] << '\n';
                 std::cout << v[1] << '\n';
             
                 for (size_t i{0}; i < 10000; ++i) {
                     decrypt(v,k);
                 }
                 std::cout << v[0] << '\n';
                 std::cout << v[1] << '\n';
                 
                 return 0;
             }
             ```
             
[X][11] (*1) How would you choose names for pointer to function types defined using a type alias?
             - I would make is explicitly clear that the type is a pointer to a function so that there is no ambiguity to the reader.
             
[X][12] (*2) Look at some programs to get an idea of the diversity of styles of names actually used. How are uppercase letters used? How is the
             underscore used? When are short names such as i and x used?
             - There are a couple different variants that I have noticed: camelCase and snake_case to name a couple.
	       I prefer snake_case; but I haven't fully formed an opinion on my thoughts of using uppercase letters for user-defined types.
             
[X][13] (*1) What is wrong with these macro definitions?
             - The `=` in the `PI` macro should not be there; as well as the semi-colon.
	     - The `MAX` macor is not properly parenthesized; it should be: `#define MAX(a,b) ((a>b)?(a):(b))`
	     - The `fac` macro should be capitalized for best-practice; but better yet should not even used, but be transformed into a `constexpr` function.
```
#define PI = 3.141593;
#define MAX(a,b) a>b?a:b
#define fac(a) (a)*fac((a)-1)
```

[X][14] (*3) Write a macro processor that defines and expands simple macros (like the C preprocessor does). Read from `std::cin` and write to `std::cout`.
             ```
	     #include <fstream>  // std::fstream
             #include <iostream> // std::cout
             #include <map>      // std::map
             #include <sstream>  // std::stringstream
             #include <string>   // std::string
             
             int main () {
                 std::map<std::string, std::string> macros;
                 std::string                        expr;
                 std::stringstream                  parser;
                 
                 while (true) {
                     std::cout << ">>> ";
                     std::getline(std::cin, expr);
             
                     parser.str(std::string{});
                     parser.clear();
             
                     parser << expr;
                     parser >> expr;
                     
                     if (expr == "#define") {
                         parser >> expr;
                         std::string key{expr};
                         macros[key];
                         
                         while(parser >> expr) {
                             macros.at(key).append(expr);
                             macros.at(key).append(" ");
                         }
                     }
             
                     if (macros.find(expr) != macros.cend())
                         std::cout << macros.at(expr) << '\n';
                 }
		 
		 return 0;
             }
             ```
             
[X][15] (*3) Write an error function that takes a printf-style format string containing `%s`, `%c`, and `%d` directives and an arbitrary number of
             arguments. Don’t use `printf()`.
             ```
	     #include <cstdarg>  // std::va_list
             #include <iostream> // std::cout
             
             void printer(const char* fmt...) {
                 std::va_list args;
                 va_start(args, fmt);
             
                 int         i;
                 int         c;
                 const char* s;
             
                 std::string res;
             
                 while (*fmt != '\0') {
                     res += *fmt;
                     if (*fmt == '%') {
                         res.pop_back();
                         switch (*++fmt) {
                             case 'd':
                                 i = va_arg(args, int);
                                 res += std::to_string(i);
                                 break;
                             case 'c':
                                 c = static_cast<char>(va_arg(args, int));
                                 res += c;
                                 break;
                             case 's':
                                 s = va_arg(args, const char*);
                                 res += s;
                                 break;
                         }
                     }
                     ++fmt;
                 }
             
                 std::cout << res << '\n';
             }
             
             int main () {
                 printer("Hello %c %s %d!", 'J', "DeBord", 7);
		 return 0;
             }
             ```
             
[X][17] (*1) Write a factorial function that does not use recursion.
             ```
	     int fac(int n) {
                 int sum{n};
                 while(n != 1)
                     sum *= --n;
                 
                 return sum;
             }
             ```
             
[X][18] (*2) Write functions to add one day to a `Date` structure; as well as add leap-year functionality.
             ```
	     #include <cassert>  // assert
             #include <iostream> // std::cout
             
             class Date {
             public:
                 Date(size_t m, size_t d, size_t y) {
                     assert(m <=   12 &&    0 < m);
                     assert(d <=   31 &&    0 < d);
                     assert(y <= 2100 && 1900 < y);
             
                     _month = m;
                     _day   = d;
                     _year  = y;
             
                     if (is_leap_year(_year))
                         days_in_month[1] = 29;
                 }
                 
                 void add_day()   {_add_day();}
             
                 void print_date() {
                     std::string res;
                     res += std::to_string(_month) +
                            '/'                    +
                            std::to_string(_day)   +
                            '/'                    +
                            std::to_string(_year);
                     std::cout << res << '\n';
                 }
             
             private:
                 size_t _month;
                 size_t _day;
                 size_t _year;
             
                 size_t days_in_month[12]{ 31,28,31,30,31,30,31,31,30,31,30,31 };
             
                 void _add_day() {
                     ++_day;
                     if (_day > days_in_month[_month-1]) {
                         _day = 1;
                         _add_month();
                     }
                 }
             
                 void _add_month() {
                     ++_month;
                     if ( (_month > (sizeof(days_in_month)/sizeof(size_t))) ) {
                         _month = 1;
                         _add_year();
                     }
                 }
             
                 void _add_year() {
                     ++_year;
                     if (is_leap_year(_year))
                         days_in_month[1] = 29;
                     else
                         days_in_month[1] = 28;
                 }
             
                 bool is_leap_year(size_t year) {
                     return !(year % 4);
                 }
             };
             
             int main () {
                 Date d{1,1,2020};
             
                 for (size_t i{0}; i < 1000; ++i) {
                     d.add_day();
                     d.print_date();
                 }
                 
                 return 0;
             }
             ```

-----------------------
X.14 Exception Handling
-----------------------
[X][1]  (*3) Write a `checked_ptr<T>` that uses exceptions to signal run-time errors for a pointer supposed to point to an element of an array (or
             one-beyond-the-end-of the array).
             ```
	     #include <exception> // std::exception
             #include <iostream>  // std::cout
             
             template<typename T>
             class checked_ptr {
             public:
                 checked_ptr(size_t n) : sz{n}, ptr{new T[n]}
                 { }
             
                 T& operator[](size_t n) {
                     if (n < 0 || n > sz-1)
                         throw std::exception{};
                     return ptr[n];
                 }
             
                 ~checked_ptr() {
                     delete[] ptr;
                 }
             
             private:
                 size_t sz;
                 T*     ptr;
             };
             
             int main () {
                 checked_ptr<int> ptr(50);
                 
                 return 0;
             }
             ```
             
[X][2]  (*3) Write a function that searches a binary tree of nodes based on a `const char*` field for a match. If a node containing hello is found,
             `find("hello")` will return a pointer to that node. Use an exception to indicate "not found".
             ```
	     #include <cstring>   // std::strcmp
             #include <iostream>  // std::cout
             
             struct node {
                 const char* str{nullptr};
                 node* left     {nullptr};
                 node* right    {nullptr};
             };
             
             void insert_node(node& root, node& node) {
                 if (std::strcmp(root.str, node.str) == -1) {
                     if (root.left == nullptr)
                         root.left = &node;
                     else
                         insert_node(*root.left,node);
                 }
                 else {
                     if (root.right == nullptr)
                         root.right = &node;
                     else
                         insert_node(*root.right,node);
                 }
             }
             
             void pre_order_search(node& root, node& res) {
                 if (&root == nullptr)
                     return;
                 if (std::strcmp(root.str, "hello") == 0)
                     res = root;
                 pre_order_search(*root.left,  res);
                 pre_order_search(*root.right, res);
             }
             
             void find(node& root, node& res) {
                 try {
                     pre_order_search(root, res);
                     if (res.str == nullptr)
                         throw std::exception{};
                 }
                 catch (...) {
                     std::cout << "Erroneous behavior encounterd.\n";
                 }
             }
             
             int main () {
                 node root{"somethin'",nullptr,nullptr};
                 
                 node nodes[7]{ {"nope",          nullptr,nullptr},
                                {"not me",        nullptr,nullptr},
                                {"not here",      nullptr,nullptr},
                                {"hello",         nullptr,nullptr},
                                {"ok",            nullptr,nullptr},
                                {"sure over here",nullptr,nullptr},
                                {"maybe here?",   nullptr,nullptr} };
             
                 for (size_t i{0}; i < 7; ++i)
                     insert_node(root,nodes[i]);
             
                 node res{};
                 find(root, res);
                 
                 return 0;
             }
             ```
             
[X][3]  (*3) Define a class `Int` that acts exactly like the built-in type `int`, except that it throws exceptions rather than overflowing or underflowing.
             ```
	     #include <cassert>   // assert
             #include <iostream>  // std::cout
             #include <limits>    // std::numeric_limits
	     #include <utility>   // std::move
             
             class Int {
             public:
                 Int() = default;
                 
                 Int(long i)  {
                     check_if_valid_int(i);
                     _i = i;
                 }
             
                 Int operator=(long i)  {
                     check_if_valid_int(i);
                     _i = i;
                     return *this;
                 }
             
                 Int(const Int& i)  {
                     _i = i._i;
                 }
             
                 Int(Int&& i)  {
                     _i = std::move(i._i);
                 }
             
                 Int operator=(const Int& i)  {
                     _i = i._i;
                     return *this;
                 }
             
                 Int operator=(Int&& i)  {
                     _i = std::move(i._i);
                     return *this;
                 }
             
                 Int operator+=(long l) {
                     check_if_valid_int((_i + l));
                     _i += l;
                     return *this;
                 }
             
                 Int operator-=(long l) {
                     check_if_valid_int((_i - l));
                     _i -= l;
                     return *this;
                 }
             
                 Int operator+(long l) {
                     *this += l;
                     return *this;
                 }
             
                 Int operator-(long l) {
                     *this -= l;
                     return *this;
                 }
             
                 friend std::ostream& operator<<(std::ostream& os, Int i);
                 friend std::istream& operator>>(std::istream& is, Int i);
             
             private:
                 int _i;
             
                 static void check_if_valid_int(long i) {
                     assert(i <= std::numeric_limits<int>::max());
                     assert(i >= std::numeric_limits<int>::min());
                 }
             };
             
             std::ostream& operator<<(std::ostream& os, const Int i) {
                 os << i._i;
                 return os;
             }
             
             std::istream& operator>>(std::istream& is, Int i) {
                 long l;
                 is >> l;
                 Int::check_if_valid_int(l);
                 i._i = l;
                 return is;
             }
             
             int main () {
                 std::cout << std::numeric_limits<long>::max() << '\n';
                 std::cout << std::numeric_limits<long>::min() << '\n';
                 std::cout << std::numeric_limits<int>::max()  << '\n';
                 std::cout << std::numeric_limits<int>::min()  << '\n';
             
                 Int i0(2147483647);
                 Int i1 = -2147483648;
                 
                 Int i2(i0);
                 Int i3(std::move(i1));
             
                 Int i4 = i2;
                 Int i5 = std::move(i3);
             
                 std::cout << "i0: " << i0 << '\n';
                 std::cout << "i1: " << i1 << '\n';
                 std::cout << "i2: " << i2 << '\n';
                 std::cout << "i3: " << i3 << '\n';
                 std::cout << "i4: " << i4 << '\n';
                 std::cout << "i5: " << i5 << '\n';
             
                 // Int i6{};
                 // std::cin >> i6;
                 // std::cin << i6;
             
                 // Int i7{ 2147483647};
                 // i7 += 1;
                 
                 // Int i8{-2147483648};
                 // i8 -= 1;
                 
                 return 0;
             }
             ```
             
[X][4]  (*2) Take the basic operation for opening from the C interface to your operating system and provide equivalent C++ function that calls the C function
             but throw exceptions in case of errors.
             ```
	     #include <cstdio>    // std::fopen
             #include <exception> // std::exception
             #include <string>    // std::string
             
             using file = FILE;
             
             file* open_file(const std::string& file_name, char mode) {
                 FILE* ptr;
                 switch (mode) {
                     case 'r':
                         ptr = std::fopen(file_name.c_str(), std::string{mode}.c_str());
                         break;
                     case 'w':
                         ptr = std::fopen(file_name.c_str(), std::string{mode}.c_str());
                         break;
                     default:
                         throw std::exception{};
                         break;
                 }
             
                 if (ptr == nullptr)
                     throw std::exception{};
                 return ptr;
             }
             
             int main () {
                 file* ptr = open_file("tmp", 'r');   
                 return 0;
             }
             ```
             
[X][5]  (*2) Write a complete `Vector` template with `Range` and `Size` exceptions.
             ```
	     #include <cstring>   // std::memcpy
             #include <exception> // std::exception
             #include <iostream>  // std::cout
             #include <utility>   // std::move
             
             template<typename T>
             class jd_vector {
             public:
                 jd_vector(size_t n) : _data{new T[n]}, _size{n}
                 { }
             
                 jd_vector(const jd_vector& vec) {
                     _data = new T[vec._size];
                     _size = vec._size;
                     std::memcpy(vec._data, _data, sizeof(T)*_size);
                 }
             
                 jd_vector(jd_vector&& vec) {
                     _data = std::move(vec._data);
                     _size = std::move(vec._size);
                 }
             
                 jd_vector operator=(const jd_vector& vec) {
                     _data = new T[vec._size];
                     _size = vec._size;
                     std::memcpy(vec._data, _data, sizeof(T)*_size);
                     return *this;
                 }
             
                 jd_vector operator=(jd_vector&& vec) {
                     _data = std::move(vec._data);
                     _size = std::move(vec._size);
                     return *this;
                 }
             
                 ~jd_vector() {
                     delete[] _data;
                 }
             
                 T& operator[](size_t n) {
                     if (n >= _size)
                         throw std::exception{};
                     return _data[n];
                 }
             
                 T operator[](size_t n) const {
                     if (n >= _size)
                         throw std::exception{};
                     return _data[n];
                 }
             
                 size_t size() const {
                     return _size;
                 }
             
             private:
                 T*     _data;
                 size_t _size;
             };
             
             int main () {
                 try {
                     jd_vector<int> vec{100};
                     
                     std::cout << vec[ 99]  << '\n';
                     std::cout << vec[101]  << '\n';
                 }
                 catch (...) {
                     std::cout << "Erroneous behavior encountered.\n";
                 }
                 
                 return 0;
             }
             ```
             
[X][6]  (*1) Write a loop that computes the sum of a `Vector` as defined above without examining the size of the `Vector`. Why is this a bad idea?
             - It's a bad idea because a naive programmer could much more easily access memory that is out of the bounds of said `Vector`'s memory limitations.
             ```
	     template<typename T>
             size_t compute_sum(const jd_vector<T>& vec, size_t sz) {
                 size_t sum{};
                 for (size_t i{0}; i < sz; ++i)
                     sum += vec[i];
                 return sum;
             }
             ```
[X][7]  (*2) Consider using a class `Exception` as the base of all classes used as exceptions. What should it look like? How should it be used? What good
             might it do? What disadvantages might result from a requirement to use such a class?
             - It should have minimal functionality to minimize runtime overhead.
	     - It should be very generic/basic; just enough to tell you that an error was encountered, what caused the invariant to fail, and where at.
	     - It should be very useful when debugging any given application.
	     - One of the only negative side-effects that I see is that it would cause that much more code to be checked during runtime; thus slowing the program
	       down slightly; albeit by a nominal amount, but still an amount nonetheless.
             
[X][8]  (*1) Given the below code, change it so that it catches all exceptions thrown from the ..., turns them into error messages, and will call `abort()`.
```
int main() { /* ... */ }
```
             ```
	     #include <cstdlib>  // std::abort
             #include <iostream> // std::cout
             
             int main () {
                 try {
                     throw std::exception{};
                 }
                 catch (...) {
                     std::cout << "Erroneous behavior encountered." << '\n';
                     std::abort();
                 }
                 
                 return 0;
             }
             ```
             
[X][9]  (*2) Write a class or template suitable for implementing callbacks.
             ```
	     #include <functional> // std::function
             #include <iostream>   // std::cout
             
             template<typename T>
             class handle_type {
             public:
                 handle_type(size_t n) : _data{new T[n]}, _size{n}
                 { }
             
                 void fill_data() {
                     for (size_t i{0}; i < _size; ++i)
                         _data[i] = i;
                 }
             
                 void transform_data(std::function<void(T&)> f) {
                     for (size_t i{0}; i < _size; ++i)
                         f(_data[i]);
                 }
             
                 void print_data() {
                     for (size_t i{0}; i < _size; ++i) 
                         std::cout << _data[i] << ' ';
                     std::cout << '\n';
                 }
                 
             private:
                 T*     _data;
                 size_t _size;
             };
             
             constexpr void f0(int& i) { i+=1; }
             constexpr void f1(int& i) { i*=2; }
             
             int main () {
                 handle_type<int> h{100};
                 
                 h.fill_data();
                 h.print_data(); std::cout << '\n';
                 h.transform_data(f0);
                 h.print_data(); std::cout << '\n';
                 h.transform_data(f1);
                 h.print_data(); std::cout << '\n';
                 h.transform_data(f1);
                 h.print_data(); std::cout << '\n';
                 
                 return 0;
             }
	     ```

[X][10] (*2) Write a program consisting of functions calling each other to a calling depth of 10. Give each function an argument that determines at which level
             an exception is thrown. Have main() catch these exceptions and print out which exception is caught. Don’t forget the case in which an exception is
	     caught in the function that throws it.
             ```
	     #include <exception> // std::exception
             #include <iostream>  // std::cout
             
             #define CALL_FUNCTION(LETTER)                                                        \
                 static const size_t maximum_call_depth{10};                                      \
                 static size_t       current_call_depth{ 0};                                      \
                 ++current_call_depth;                                                            \
                 std::cout << "`call_"#LETTER"`" << "call depth: " << current_call_depth << '\n'; \
                 if (current_call_depth == n || current_call_depth == maximum_call_depth)         \
                     throw std::runtime_error{"Thrown in `call_"#LETTER"`"};                      \
                 call_##LETTER(n);
             
             void call_a(size_t n);
             void call_b(size_t n);
             
             void call_a(size_t n) {
                 CALL_FUNCTION(b)
             }
             
             void call_b(size_t n) {
                 CALL_FUNCTION(a)
             }
             
             int main () {
                 try {
                     call_a(2);
                 }
                 catch (const std::exception& e) {
                     std::cout << e.what() << '\n';
                 }
                 catch (...) {
                     std::cout << "Erroneous behavior encountered.\n";
                 }
                 
                 return 0;
             }
             ```
             
[X][11] (*2) Modify the program above to measure if there is a difference in the cost of catching exceptions depending on where in the function call stack
             the exception is thrown.
             ```
	     #include <chrono>    // std::chrono::high_resolution_clock
             #include <exception> // std::runtime_error
             #include <iostream>  // std::cout
             
             using namespace std::chrono;
             
             static high_resolution_clock::time_point t1;
             static high_resolution_clock::time_point t2;
             static size_t current_call_depth{0};
                                     
             #define MEASURE_START                            \
                 std::cout << "---STARTING MEASUREMENT---\n"; \
                 t1 = high_resolution_clock::now();           \
                                             
             #define MEASURE_STOP                                           \
                 t2 = high_resolution_clock::now();                         \
                 auto duration{duration_cast<microseconds>(t2-t1).count()}; \
                 std::cout << "Duration: " << duration << '\n';             \
                 std::cout << "---STOPPING MEASUREMENT---\n\n";
             
             #define CALL_FUNCTION(LETTER)                                   \
                 ++current_call_depth;                                       \
                 if (current_call_depth == n) {                              \
                     current_call_depth = 0;                                 \
                     MEASURE_START                                           \
                     throw std::runtime_error{"Thrown in `call_"#LETTER"`"}; \
                 }                                                           \
                 call_##LETTER(n);
             
             void call_a(size_t n);
             void call_b(size_t n);
             
             void call_a(size_t n) {
                 CALL_FUNCTION(b)
             }
             
             void call_b(size_t n) {
                 CALL_FUNCTION(a)
             }
             
             int main () {
                 try {
                     call_a(100000);
                 }
                 catch (const std::exception& e) {
                     std::cout << e.what() << '\n';
                     MEASURE_STOP
                 }
                 
                 return 0;
             }
             ```
             
[X][12] (*2) Write a function that either returns a value or that throws that value based on an argument. Measure the difference in run-time between the two ways.
             ```
	     #include <chrono>    // std::chrono::high_resolution_clock
             #include <exception> // std::runtime_error
             #include <iostream>  // std::cout
             
             using namespace std::chrono;
                          
             static high_resolution_clock::time_point t1;
             static high_resolution_clock::time_point t2;
                                                  
             #define MEASURE_START                            \
                 std::cout << "---STARTING MEASUREMENT---\n"; \
                 t1 = high_resolution_clock::now();           \
                                                          
             #define MEASURE_STOP                                            \
                 t2 = high_resolution_clock::now();                          \
                 auto duration{duration_cast<microseconds>(t2-t1).count()};  \
                 std::cout << "Duration: " << duration << '\n';              \
                 std::cout << "---STOPPING MEASUREMENT---\n\n";
             
             size_t return_or_throw(size_t n) {
                 if (n == 10) {
                     MEASURE_START
                     throw std::runtime_error{"Threw in `return_or_throw`"};
                 }   
                 else {
                     MEASURE_START
                     return n;
                 }
             }
             
             int main () {
                 try {
                     return_or_throw(10);
                     std::cout << "Got 'em" << '\n';
                     MEASURE_STOP
                 }
                 catch (const std::exception& e) {
                     std::cout << e.what() << '\n';
                     MEASURE_STOP
                 }
                 
                 return 0;
             }
             ```

----------
X.16 Files
----------
[X][1] (*2) Find where the standard library headers are kept on your system. Are any nonstandard headers kept together with the standard ones?
            Can any nonstandard headers be #included using the <> notation?
            - `/usr/include/`.
	    - Yes, I there are many nonstandard ones that are useful for the current system I'm using (Linux Mint).
	    - Yes, but you must give the appropriate path.
            
[X][2] (*2) Where are the headers for nonstandard "foundation" libraries kept?
            - If this question is referring to 3rd party headers, my system seems to store them in directory `/usr/local/`.
            
[X][3] (*2) Write a program that reads a source file and writes out the names of files #included.
            ```
	    #include <exception> // std::exception
            #include <fstream>   // std::fstream
            #include <iostream>  // std::cout
            #include <string>    // std::string
            
            int main (int argc, char* argv[]) {
                try {
                    if (argc != 2)
                        throw std::exception{};
                    
                    std::fstream f{argv[1]};
                    
                    if (!f)
                        throw std::exception{};
                    
                    std::string s;
                    while (f >> s) {
                        if (s == "#include") {
                            f.get();
                            if (f.peek() == '<' || f.peek() == '\"') {
                                f.get();
                                f >> s;
                                s.pop_back();
                                std::cout << s << '\n';
                            }
                        }    
                    }
                } catch (...) {
                    std::cout << "Erroneous behavior encountered.\n";
                }
            }
            ```
            
[X][4] (*3) How is dynamic linking achieved on your system? What restrictions are placed on dynamically linked code? What requirements are placed on
            code for it to be dynamically linked?
            - According to an article written on IBM's website, the kernel first loads the ELF image into virtual memory and then notices a section in
	      the file called `.interp` which indicates that the dynamic linker, `/lib/ld-linux.so`, be used for this image. After which (to the best of
	      my understanding thus far), the kernel does some work under the hood to call the appropriate functions in their respective libraries.
	    - One restriction is that the user of the ELF image must have the `*.so` shared library on his/her computer in order to run the program.
	    - Like I mentioned above, a requirement is that the user must have said files in order to run the program. In contrast, if a user had a
	      statically linked version of the program, the user wouldn't need to worry about dynamic linking (to the best of my understanding), albeit
	      the user in turn will have to deal with a larger file and thus keep that in mind when working with the program.
            
[X][5] (*3) Open and read 100 files containing 1500 characters each. Open and read one file containing 150,000 characters. Is there a performance
            difference? Consider this question in relation to the use of #included files.
            - Reading one large file seems to be three times faster than reading multiple small files of when both are equivalent in nature.
	    ```
	    #include <chrono>   // std::chrono::high_resolution_clock
            #include <fstream>  // std::fstream
            #include <iostream> // std::cout
            #include <string>   // std::string, std::to_string
            
            using namespace std::chrono;
                                      
            static high_resolution_clock::time_point t1;
            static high_resolution_clock::time_point t2;
                                                              
            #define MEASURE_START                            \
                {                                            \
                std::cout << "---STARTING MEASUREMENT---\n"; \
                t1 = high_resolution_clock::now();           \
                                                                      
            #define MEASURE_STOP                                           \
                t2 = high_resolution_clock::now();                         \
                auto duration{duration_cast<microseconds>(t2-t1).count()}; \
                std::cout << "Duration: " << duration << '\n';             \
                std::cout << "---STOPPING MEASUREMENT---\n\n";             \
                }
            
            class reading_test {
            public:
                reading_test() = default;
            
                void make_small_files() {
                    content = std::string(100, 'X');
                    for (size_t i{0}; i < 100; ++i) {
                        file_name = "/home/i/tmp/file" + std::to_string(i);
                        file.open(file_name, std::fstream::out);
                        file << content;
                        file.close();
                    }
                }
            
                void make_large_file() {
                    content   = std::string(150000, 'X');
                    file_name = "/home/i/tmp/huge";
                    file.open(file_name, std::fstream::out);
                    file << content;
                    file.close();
                }
            
                void read_small_files() {
                    std::string temp;
                    for (size_t i{0}; i < 100; ++i) {
                        file_name = "/home/i/tmp/file" + std::to_string(i);
                        file.open(file_name, std::fstream::in);
            
                        while (!file.eof())
                            file >> temp;
                        
                        file.close();
                    }
                }
            
                void read_huge_file() {
                    std::string temp;
                    file_name = "/home/i/tmp/huge";
                    file.open(file_name, std::fstream::in);
            
                    while (!file.eof())
                        file >> temp;
                    
                    file.close();
                }
            
            private:
                std::fstream file;
                std::string  file_name;
                std::string  content;
            };
                        
            int main () {
                reading_test rt;
                rt.make_small_files();
                rt.make_large_file();
            
                MEASURE_START
                rt.read_small_files();
                MEASURE_STOP
            
                MEASURE_START
                rt.read_huge_file();
                MEASURE_STOP
                
                return 0;
            }
	    ```
	    
------------
X.17 Classes
------------
[X][4]  (*2) Define a class, `histogram`, that keeps count of numbers in some intervals specified as arguments to `histogram`’s constructor. Provide
             functions to print out the histogram. Handle out-of-range values.
	     ```
	     #include <cassert>   // assert
             #include <exception> // std::runtime_error
             #include <iostream>  // std::cin, std::cout
             #include <utility>   // std::pair
             
             template<typename T>
             class histogram {
             public:
                 histogram(size_t lower_bound, size_t upper_bound)
                 :   _size  {upper_bound - lower_bound}
                 ,   _handle{new T[_size]}
                 ,   _range {lower_bound, upper_bound}
                 { }
             
                 ~histogram() {
                     delete[] _handle;
                 }
             
                 T& operator[](size_t n) {
                     return _handle[n-_size];
                 }
             
                 void print_histogram() const {
                     for (size_t i{0}; i < _size; ++i) {
                         std::cout << std::get<0>(_range)+i << ": ";
                         for (size_t j{0}; j < _handle[i]; ++j)
                             std::cout << '-';
                         std::cout << '\n';
                     }
                 }
                     
             public:
                 size_t                    _size;
                 T*                        _handle;
                 std::pair<size_t, size_t> _range;
             
                 void check_range(T t) const {
                     if (t < std::get<0>(_range) || t >= std::get<1>(_range))
                         throw std::runtime_error{"Out of range access."};
                 }
             
                 template<typename U>
                 friend std::istream& operator>>(std::istream& is, histogram<U>& h);
             };
             
             template<typename U>
             std::istream& operator>>(std::istream& is, histogram<U>& h) {
                 U t;
                 std::cin >> t;
                 if (std::cin) {
                     h.check_range(t);
                     ++h[t];
                 }
                 return is;
             }
                         
             int main() {
                 histogram<size_t> hist{5, 10}; // Range: [5,10)
                 
                 while (std::cin >> hist);
             
                 hist.print_histogram();
                 
                 return 0;
             }
	     ```
	     
[X][5]  (*2) Define a class, `table`, to hold {name,value} pairs.
             ```
	     #include <iostream> // std::cout
             #include <vector>   // std::vector
             #include <string>   // std::string
             #include <utility>  // std::pair
             
             class table {
             public:
                 table() = default;
             
                 void insert_pair(std::string name, size_t value) {
                     _data.push_back( {name, value} );
                 }
             
                 void print_table() {
                     for (const auto& p : _data) {
                         std::cout << "name:\t"  << std::get<0>(p);
                         std::cout << '\n';
                         std::cout << "value:\t" << std::get<1>(p);
                         std::cout << '\n';
                     }
                 }
             
             private:
                 std::vector<std::pair<std::string,size_t>> _data;
             };
             
                         
             int main() {
                 table t;
                 t.insert_pair("John",  25);
                 t.insert_pair("Parker",25);
                 t.insert_pair("Brist", 25);
                 t.insert_pair("Kayla", 27);
                 t.print_table();
                 
                 return 0;
             }
	     ```
	     
[X][7]  (*3) Define, implement, and test a set of integers, class `intset`. Provide union, intersection, and symmetric difference operations.
             ```
	     #include <iostream> // std::cout
             #include <set>      // std::set
             
             class intset { // Definitely not an optimal solution; duplicated code
             public:
                 intset() = default;
                 
                 intset(const std::set<int>& set) : _set{set}
                 { }
             
                 intset(const intset& set) : _set{set._set}
                 { }
             
                 intset operator=(const std::set<int>& set) {
                     _set = set;
                     return *this;
                 }
                 
                 intset operator=(const intset& set) {
                     _set = set._set;
                     return *this;
                 }
             
                 intset union_set(const intset& set) {
                     intset ret;
                     for (const auto& i : set._set)
                         ret._set.insert(i);
                     return ret;
                 }
             
                 intset intersection_set(const intset& set) {
                     intset ret;
                     for (const auto& i : set._set)
                         if (_set.find(i) != _set.cend())
                             ret._set.insert(i);
                     return ret;
                 }
             
                 intset symmetric_diff_set(const intset& set) {
                     intset ret;
                     for (const auto& i : _set)
                         if (set._set.find(i) == set._set.cend())
                             ret._set.insert(i);
                     for (const auto& i : set._set)
                         if (_set.find(i) == _set.cend())
                             ret._set.insert(i);
                     return ret;
                 }
             
                 void print_set() {
                     std::cout << '{';
                     for (const auto& i : _set)
                         std::cout << i << ',';
                     std::cout << "\b}\n";
                 }
             
             private:
                 std::set<int> _set;
             };
                         
             int main() {
                 intset s0{ std::set<int>{1,2,3} };
                 intset s1{ std::set<int>{2,3,4} };
                 s0.print_set(); s1.print_set();
             
                 intset s3{ s0.union_set(s1) };
                 s3.print_set();
             
                 s3 = s0.intersection_set(s1);
                 s3.print_set();
             
                 s3 = s0.symmetric_diff_set(s1);
                 s3.print_set();
                 
                 return 0;
             }
	     ```
	     
[X][8]  (*1) Modify class `intset` into a generic structure.
             ```
	     #include <iostream> // std::cout
             #include <set>      // std::set
             
             template<typename T>
             class intset { // Definitely not an optimal solution; duplicated code
             public:
                 intset() = default;
                 
                 intset(const std::set<T>& set) : _set{set}
                 { }
             
                 intset(const intset& set) : _set{set._set}
                 { }
             
                 intset operator=(const std::set<T>& set) {
                     _set = set;
                     return *this;
                 }
                 
                 intset operator=(const intset& set) {
                     _set = set._set;
                     return *this;
                 }
             
                 intset union_set(const intset& set) {
                     intset ret;
                     for (const auto& i : set._set)
                         ret._set.insert(i);
                     return ret;
                 }
             
                 intset intersection_set(const intset& set) {
                     intset ret;
                     for (const auto& i : set._set)
                         if (_set.find(i) != _set.cend())
                             ret._set.insert(i);
                     return ret;
                 }
             
                 intset symmetric_diff_set(const intset& set) {
                     intset ret;
                     for (const auto& i : _set)
                         if (set._set.find(i) == set._set.cend())
                             ret._set.insert(i);
                     for (const auto& i : set._set)
                         if (_set.find(i) == _set.cend())
                             ret._set.insert(i);
                     return ret;
                 }
             
             private:
                 std::set<T> _set;
             
                 template<typename U>
                 friend std::ostream& operator<<(std::ostream& os, const intset<U>& set);
             };
             
             template<typename U>
             std::ostream& operator<<(std::ostream& os, const intset<U>& set) {
                 os << '{';
                 for (const auto& i : set._set)
                     os << i << ',';
                 os << "\b}";
                 return os;
             }
                         
             int main() {
                 intset s0{ std::set<int>{1,2,3} };
                 intset s1{ std::set<int>{2,3,4} };
                 std::cout << s0 << '\n';
                 std::cout << s1 << '\n';
             
                 intset s3{ s0.union_set(s1) };
                 std::cout << s3 << '\n';
             
                 s3 = s0.intersection_set(s1);
                 std::cout << s3 << '\n';
             
                 s3 = s0.symmetric_diff_set(s1);
                 std::cout << s3 << '\n';
                 
                 return 0;
             }
	     ```
	     
[X][9]  (*3) Define a class for analyzing, storing, evaluating, and printing simple arithmetic expressions consisting of integer constants and the
             operators `+`, `-`, `*`, and `/`. The string argument for the constructor `expr::expr()` is the expression. The function `expr::eval()`
	     returns the value of the expression.
```
class expr {
// ...
public:
    expr(const std::string&);
    int  eval();
    void print();
};
```
```
expr x("123/4+123*4-3");
x.eval();
x.print();
```
             ```
	     #include <cctype>    // std::isdigit
             #include <deque>     // std::deque
             #include <iostream>  // std::cout
             #include <string>    // std::string, std::stoi
             
             class expr {
             public:
                 expr(const std::string& ex) : _ex{ex}
                 { }
             
                 int eval() {
                     std::deque<int>  terms;
                     std::deque<char> opts;
             
                     parse_expression(terms, opts);
                     return calculate_expression(terms, opts);
                 }
             
             private:
                 std::string _ex;
                 
                 void parse_expression(std::deque<int>& terms, std::deque<char>& opts) {
                     std::string term;
                     auto        it {_ex.cbegin()};
                     while(it != _ex.cend()) {
                         if (std::isdigit(*it)) {
                             term.push_back(*it++);
                             if (it == _ex.cend())
                                 terms.push_back(std::stoi(term));
                         }
                             
                         if (*it == '+' || *it == '-' || *it == '*' || *it == '/') {
                             if (!term.empty()) {
                                 terms.push_back(std::stoi(term));
                                 term.clear();
                             }
                             opts.push_back(*it++);
                         }
                     }
                 }
             
                 int calculate_expression(std::deque<int>& terms, std::deque<char>& opts) {
                     int res{};
                     while(!opts.empty()) {
                         switch (opts[0]) {
                             case '+':
                                 terms[0] = +terms[0];
                                 opts.pop_front();
                                 break;
                             case '-':
                                 terms[0] = -terms[0];
                                 opts.pop_front();
                                 break;
                             case '*':
                                 res += terms[0] * terms[1];
                                 terms.pop_front(), terms.pop_front();
                                 opts.pop_front();
                                 break;
                             case '/':
                                 res += terms[0] / terms[1];
                                 terms.pop_front(), terms.pop_front();
                                 opts.pop_front();
                                 break;
                         }
                     }
                     // For the lonely straggler case that may follow.
                     if (!terms.empty())
                         res += terms[0];
                     return res;
                 }
             };
                         
             int main() {
                 expr x{"123/4+123*4-3"};
                 std::cout << x.eval() << '\n';
                 std::cout << (123/4+123*4-3) << '\n';
             
                 return 0;
             }
	     ```
	     
[X][13] (*1) Given this program, modify it to produce the output that follows; do not change `main()` in any way.
```
#include <iostream>
int main() {
    std::cout << "Hello, world!\n";
}
``` 
```
Initialize
Hello, world!
Clean up
```
             ```
	     #include <iostream> // std::cout

             class simple {
             public:
                 simple() {
                     std::cout << "Initialize\n";
                 }
             
                 ~simple() {
                     std::cout << "Clean up\n";
                 }
             };
             
             static simple s;
             
             int main() {
                 std::cout << "Hello, world!\n";
             }
	     ```
             
[X][14] (*2) Define two classes, each with a static member, so that the construction of each static member involves a reference to the other. Where
             might such constructs appear in real code? How can these classes be modified to eliminate the order dependence in the constructors?
	     - In my opinion it would be an over-complication if this pattern were implemented.
	     - You can eliminate the dependence of ordering by seperating out the constructor definitions.
	     ```
	     #include <iostream> // std::cout

            struct s0 {
                s0();
                int        i;
                static int s;
            };
            
            struct s1 {
                s1();
            
                int        i;
                static int s;
            };
            
            int s0::s{0};
            int s1::s{1};
            
            s0::s0() : i{s1::s}
            { }
            
            s1::s1() : i{s0::s}
            { }
            
            int main() {
                s0 ss0;
                s1 ss1;
            
                std::cout << ss0.i << '\n';
                std::cout << ss1.i << '\n';
                
                return 0;
            }
	     ```

------------------------------------------
X.18 Construction, Cleanup, Copy, and Move
------------------------------------------
[X][1] (*2) Implement a class that does nothing but print out their name and the address of their object.
	    ```
	    #include <iostream> // std::cout

            struct s {
                void print_self() {
                    std::cout << &*this << '\n';
                }
            };
            
            int main() {
                s obj0, obj1;
                obj0.print_self();
                obj1.print_self();
            
                return 0;
            }
	    ```
	    
[X][2] (*2) Define `resource_handle`, a smart pointer that holds a pointer to an object on the free store passed as an argument to a constructor.
            "Forget" to define copy operations.
	    ```
	    #include <iostream> // std::cout

            template<typename T>
            class resource_handle {
            public:
                resource_handle(T* ptr, const size_t size) : _ptr{ptr}, _size{size} {
                    std::cout << "Constructing\n";
                }
                
                resource_handle()                                 = delete;
                resource_handle(resource_handle&)                 = delete;
                resource_handle(const resource_handle&)           = delete;
                resource_handle(resource_handle&&)                = delete;
                resource_handle operator=(resource_handle&)       = delete;
                resource_handle operator=(const resource_handle&) = delete;
                resource_handle operator=(resource_handle&&)      = delete;
            
                ~resource_handle() {
                    std::cout << "Deleting\n";
                    
                    if (_size > 1) {
                        delete[] _ptr;
                    }
                    else {
                        delete _ptr;
                    }
                }
            
            private:
                T*     _ptr;
                size_t _size;
            };
            
            
            int main() {
                int*    ptr0{new int[50]};
                double* ptr1{new double[50]};
            
                resource_handle r0{ptr0,50};
                resource_handle r1{ptr1,50};
            
                return 0;
            }
	    ```
	    
[X][3] (*1) When do you need a constructor? When do memberwise construction suffice? When is memberwise construction preferable?
            - You do not need a constructor.
	    - Memberwise construction, to the best of my knowledge, suffices if the data structure is a POD type.
	    - I could see it being preferable if implementing very basic concrete structures that should have minimal complexity.
	    
[X][4] (*1) Design, implement and test a `jd_vector` class with an `std::initializer-list` constructor and no constructor that takes an integer as a size.
	    ```
	    #include <iostream>         // std::cout
            #include <initializer_list> // std::initializer_list
            
            // Probably not the correct way to implement a `std::initializer_list` constructor.
            template<typename T>
            class jd_vector {
            public:
                jd_vector(std::initializer_list<T> il) : _size{il.size()}, _data{new T[_size]} {
                    size_t i{0};
                    for (auto iter{il.begin()}; iter != il.end(); ++i, ++iter) {
                        _data[i] = std::move(*iter);
                    }
                }
            
                jd_vector(int) = delete;
                
                jd_vector()                           = delete;
                jd_vector(jd_vector&)                 = delete;
                jd_vector(const jd_vector&)           = delete;
                jd_vector(jd_vector&&)                = delete;
                jd_vector operator=(jd_vector&)       = delete;
                jd_vector operator=(const jd_vector&) = delete;
                jd_vector operator=(jd_vector&&)      = delete;
            
                T* data() {
                    return _data;
                }
            
                size_t size() {
                    return _size;
                }
            
                ~jd_vector() {
                    delete[] _data;
                }
            
            private:
                size_t _size;
                T*     _data;
            };
            
            int main() {
                jd_vector<int> vec{0,1,2,3,4,5,6,7,8,9};
                std::cout << vec.data() << '\n';
                std::cout << vec.size() << '\n';
            
                for (size_t i{0}; i < vec.size(); ++i) {
                    std::cout << vec.data()[i] << ' ';
                }
                
                return 0;
            }
	    ```
	    
[X][5] (*3) Write an extremely simple document editor with only two commands: `insert` and `backspace`.
	    ```
	    #include <cstdio>    // getch
            #include <exception> // std::runtime_error
            #include <iostream>
            
            #include <curses.h>  // For text editor emulation.
            
            class text_buffer {
            public:
                text_buffer() {
                    initscr();
                    refresh();
                }
            
                text_buffer(const text_buffer&)            = delete;
                text_buffer(text_buffer&)                  = delete;
                text_buffer(text_buffer&&)                 = delete;
                text_buffer operator= (const text_buffer&) = delete;
                text_buffer operator= (text_buffer&)       = delete;
                text_buffer operator= (text_buffer&&)      = delete;
            
                ~text_buffer() {
                    clear();
                    refresh();
                    endwin();
                }
            
                void run_main_loop() {
                    int ch{};
                    while ( (ch = getch()) ) {
                        if (pos() != end()-1) {
                            switch (ch) {
                                case 0x7F: // Backspace.
                                    backspace();
                                    print_buffer();
                                    break;
                                default:
                                    insert(ch);
                                    print_buffer();
                                    break;
                            }
                        }
                        else {
                            throw std::runtime_error{"Buffer overflow."};
                        }
                    }
                }
                
                void print_buffer() {
                    clear();
                    printw(_data);
                    refresh();
                }
                
                void insert(char ch) {
                    *_pos++ = ch;
                }
            
                void backspace() {
                    if (_pos != begin()) {            
                        *(--_pos) = '\0';
                    }
                    else {
                        throw std::runtime_error{"Buffer underflow."};
                    }
                }
            
                char* data() {
                    return _data;
                };
                
                char* pos() {
                    return _pos;
                };
                
                char* begin() {
                    return _data;
                };
                
                char* end() {
                    return _data+256;
                };
                
            private:
                char   _data[256]{};
                char*  _pos      {_data};
            };
            
            int main() {
                static text_buffer buf;
                buf.run_main_loop();
                
                return 0;
            }
	    ```
	    
----------------
X.19 Overloading
----------------
[X][3]  (*2) Define a class `jd_int` that behaves exactly like an int.
             ```
	     #include <iostream> // std::istream, std::ostream
             
             class jd_int {
             public:
                 jd_int(int i) : _i{i} { }
                              
                 jd_int& operator= (int i)    { _i = i; return *this; }
                 jd_int& operator= (double d) { _i = d; return *this; }
                          
                 explicit operator bool()   const { return !!_i;                    }
                 explicit operator int()    const { return static_cast<int>(_i);    }
                 explicit operator double() const { return static_cast<double>(_i); }
                          
                 jd_int& operator+=(jd_int jdi)       { _i += jdi._i; return *this;      }
                 jd_int  operator+ (jd_int jdi) const { return jd_int{*this} +=  jdi._i; }
                 jd_int  operator+ ()           const { return jd_int{+_i};              }
                          
                 jd_int& operator-=(jd_int jdi)       { _i -= jdi._i; return *this;      }
                 jd_int  operator- (jd_int jdi) const { return jd_int{*this} -=  jdi._i; }
                 jd_int  operator- ()           const { return jd_int{-_i};              }
                          
                 jd_int& operator*=(jd_int jdi)       { _i *= jdi._i; return *this;      }
                 jd_int  operator* (jd_int jdi) const { return jd_int{*this} *=  jdi._i; }
                          
                 jd_int& operator/=(jd_int jdi)       { _i /= jdi._i; return *this;      }
                 jd_int  operator/ (jd_int jdi) const { return jd_int{*this} /=  jdi._i; }
                          
                 jd_int& operator%=(jd_int jdi)       { _i %= jdi._i; return *this;      }
                 jd_int  operator% (jd_int jdi) const { return jd_int{*this} %=  jdi._i; }
                          
                 jd_int& operator++()    { ++_i; return *this;           }
                 jd_int  operator++(int) { ++_i; return --jd_int{*this}; }
                          
                 jd_int& operator--()    { --_i; return *this;           }
                 jd_int  operator--(int) { --_i; return ++jd_int{*this}; }
                          
                 friend bool operator< (jd_int lhs, jd_int rhs) { return (lhs._i <  rhs._i); }
                 friend bool operator> (jd_int lhs, jd_int rhs) { return (lhs._i >  rhs._i); }
                 friend bool operator<=(jd_int lhs, jd_int rhs) { return (lhs._i <= rhs._i); }
                 friend bool operator>=(jd_int lhs, jd_int rhs) { return (lhs._i >= rhs._i); }
                 friend bool operator==(jd_int lhs, jd_int rhs) { return (lhs._i == rhs._i); }
                 friend bool operator!=(jd_int lhs, jd_int rhs) { return (lhs._i != rhs._i); }
                              
             private:
                 int _i;
                          
                 friend std::ostream& operator<<(std::ostream& os, const jd_int jdi) { return os << jdi._i; }
                 friend std::istream& operator>>(std::istream& is, jd_int jdi)       { return is >> jdi._i; }
             };
             
             int main() {         
                 jd_int jdi0{0};     std::cout << jdi0 << '\n'; // 0
                 jd_int jdi1 = 1;    std::cout << jdi1 << '\n'; // 1
                 jd_int jdi2{jdi1};  std::cout << jdi2 << '\n'; // 1
                 jd_int jdi3 = jdi2; std::cout << jdi3 << '\n'; // 1
                          
                 double d1{3.14};
                              
              // jd_int jdi4{d1};  std::cout << jdi4 << '\n';  // Does and should not compile.
                 jd_int jdi5(d1);  std::cout << jdi5 << '\n'; // 3
                 jd_int jdi6 = d1; std::cout << jdi6 << '\n'; // 3
                          
                 std::cout << (jdi1 + jdi1) << '\n'; // 2
                 std::cout << (jdi1 - jdi1) << '\n'; // 0
                 std::cout << (jdi1 * jdi1) << '\n'; // 1
                 std::cout << (jdi1 / jdi1) << '\n'; // 1
                 std::cout << (jdi1 % jdi1) << '\n'; // 0
                          
                 std::cout << (++jdi1) << '\n'; // 2
                 std::cout << (jdi1++) << '\n'; // 2
                 std::cout << (--jdi1) << '\n'; // 2
                 std::cout << (jdi1--) << '\n'; // 2
             
                 std::cout << +jdi1 << '\n'; //  1
                 std::cout << -jdi1 << '\n'; // -1
                 std::cout <<  jdi1 << '\n'; //  1
                          
                 std::cout << (jdi0 <  jdi1) << '\n'; // 1
                 std::cout << (jdi0 >  jdi1) << '\n'; // 0
                 std::cout << (jdi0 <= jdi1) << '\n'; // 1
                 std::cout << (jdi0 >= jdi1) << '\n'; // 0
                 std::cout << (jdi0 != jdi1) << '\n'; // 1
                 std::cout << (jdi0 == jdi1) << '\n'; // 0
                              
                 return 0;
             }
	     ```
	     
[X][6]  (*4) Define a class implementing arbitrary precision addition with and unsigned integer.
             ```
	     #include <deque>    // std::deque
             #include <iostream> // std::cout
             #include <string>   // std::string
             
             class bignum { // I really do think this is not the optimal solution
             public:
                 bignum(std::string num) : _num{to_bignum(num)}
                 { }
             
                 void print()  const { std::cout << to_string(); }
                 size_t size() const { return _num.size();       }
             
                 bignum& operator+=(const bignum& bn) {
                     std::deque<size_t>  tmp             {(size() < bn.size()) ? (_num) : (bn._num)};
                     const size_t        max_operand_size{(size() > bn.size()) ? (_num.size()) : (bn._num.size())};
                     const size_t        size_diff{max_operand_size-tmp.size()};
                     for (size_t i{0}; i < size_diff; ++i) {
                         tmp.push_front(0);
                     }
             
                     size_t carry_flag{false};
                     for (int i{static_cast<int>(max_operand_size)-1}; i >= 0; --i) {
                         if ((_num[i] + tmp[i]) > 9) {
                             _num[i]    = ((_num[i] + tmp[i] + carry_flag) % 10);
                             carry_flag = true;
                         }
                         else {
                             _num[i]    = ((_num[i] + tmp[i] + carry_flag) % 10);
                             carry_flag = false;
                         }
                     }
             
                     if (carry_flag == true) {
                         _num.push_front(1);
                     }
                     return *this;
                 }
             
             private:
                 std::deque<size_t> _num;
             
                 std::deque<size_t> const to_bignum(const std::string& str) {
                     std::deque<size_t> res(str.size());
                     for (size_t i{0}; i < str.size(); ++i) {
                         res[i] = static_cast<size_t>(str[i]-'0');
                     }
                     return res;
                 }
             
                 std::string to_string() const {
                     std::string res(_num.size(), ' ');
                     for (size_t i{0}; i < _num.size(); ++i) {
                         res[i] =_num[i] + '0';
                     }
                     return res;
                 }
             };
             
             int main() {
                 std::string num0{"12345"};
                 std::string num1{"99999"};
                 bignum      n0  {num0};
                 bignum      n1  {num1};
             
                 n0.print(); std::cout << '\n';
                 n1.print(); std::cout << '\n';
             
                 n0+=n1;
                 n0.print();
             
                 return 0;
             }
	     ```
             
[X][14] (*1) Define a class `index` to hold the index for an exponentiation function `mypow(double,index)`. Find a way to have `2**i` call `mypow(2,i)`.
             ```
	     #include <cmath>    // std::pow
             #include <iostream> // std::cout
             
             class index {
             public:
                 index(size_t index) : _index{index}
                 { }
             
                 size_t mypow(size_t lhs, size_t rhs) {
                     return std::pow(lhs,rhs);
                 }
             
                 index operator* () {
                     return *this;
                 }
             
             private:
                 size_t _index;
             
                 friend size_t operator* (size_t lhs, index rhs);
             };
             
             size_t operator* (size_t lhs, index rhs) {
                 return rhs.mypow(lhs,rhs._index);
             }
             
             int main() {
                 index  i {2};
                 size_t st{7};
                 std::cout << st**i << '\n';
                 return 0;
             }
	     ```

-----------------------
X.20 Special Operations
-----------------------
[X][1] (*2) Define a class `ptr` and test it. To be complete, `ptr` must have at least the operators `*`, `->`, `=`, `++`, and `--` defined. Do not
            cause a run-time error until a wild pointer is actually dereferenced.
	    ```
	    #include <iostream> // std::cout

            struct test {
                int field{10};
            };
            
            template<typename T>
            class ptr {
            public:
                ptr(T elem, size_t size) : _size{size}, _pos{0}, _ptr{new T[_size]{elem}}
                { }
            
                ptr& operator= (const ptr& p) {
                    _ptr.~ptr();
                    
                    _size = p._size;
                    _pos  = 0;
                    _ptr  = new T[p._size];
                    
                    for (size_t i{0}; i < p._size; ++i) {
                        _ptr[i] = p._ptr[i];
                    }
                    return *this;
                }
            
                void reset() {
                    _pos = 0;
                }
            
                ~ptr() {
                    delete[] _ptr;
                }
            
                T& operator* () {
                    if (_pos > _size) {
                        throw std::runtime_error{"ptr::operator*()"};
                    }
                    else {
                        return *(_ptr+_pos);
                    }
                }
            
                T* operator->() {
                    if (_pos > _size) {
                        throw std::runtime_error{"ptr::operator->()"};
                    }
                    else {
                        return (_ptr+_pos);
                    }
                }
            
                void operator++() {
                    ++_pos;
                }
            
                void operator--() {
                    --_pos;
                }
            
            private:
                size_t _size;
                size_t _pos;
                T*     _ptr;
            };
            
            
            int main() {
                {
                    const size_t elem{100};
                    ptr<size_t>  p   {elem, 100};
            
                    for (size_t i{0}; i < 100; ++i, ++p) {
                        *p = i;
                    }
            
                    p.reset();
                    for (size_t i{0}; i < 100; ++i, ++p) {
                        std::cout << *p << ' ';
                    }
                    std::cout << '\n';
                }
            
                {
                    test t;
                    ptr<test> p {t, 1};
                    std::cout << p->field << '\n';
                }
                
                return 0;
            }
	    ```
	    
--------------------
X.21 Derived Classes
--------------------
[X][1]  (*1) Derive two classes from `base`, and for each define `iam()` to write out the name of the class. Create objects of these classes and call `iam()`
             for them. Assign pointers to objects of the derived classes to `base*` pointers and call `iam()` through those pointers.
```
class base {
public:
    virtual void iam() { cout << "base\n"; }
};
```
             ```
	     #include <iostream> // std::cout

             class base {
             public:
                 virtual void iam() { std::cout << "base\n"; }
             };
             
             class derived_a : public base {
             public:
                 virtual void iam() override { std::cout << "a\n"; }
             };
             
             class derived_b : public base {
             public:
                 virtual void iam() override { std::cout << "b\n"; }
             };
             
             int main() {
                 base*      b {new base{}};
                 derived_a* da{new derived_a{}};
                 derived_b* db{new derived_b{}};
             
                 b->iam();
                 da->iam();
                 db->iam();
                 
                 return 0;
             }
	     ```
             
[X][2]  (*3) Using whatever graphics facilities are available on your system display a simple "child’s drawing of a house" with a roof, two windows,
             and a door.
	     ```
	     #include <SFML/Window.hpp>   // sf::RenderWindow
             #include <SFML/Graphics.hpp> // sf::CircleShape, sf::RectanlgeShape
             
             class asset {
             public:
                 virtual sf::Shape* get_shape()=0;
             };
             
             class rectangle_asset : public asset {
             public:
                 rectangle_asset(size_t width, size_t height, size_t x, size_t y) {
                     _rec    = new sf::RectangleShape;
                     _width  = width;
                     _height = height;
                     _x      = x;
                     _y      = y;
                     
                     _rec->setSize(sf::Vector2f(_width, _height));
                     _rec->setPosition(_x,_y);
                     _rec->setOutlineColor(sf::Color::Blue);
                     _rec->setOutlineThickness(5);
                 }
             
                 ~rectangle_asset() {
                     delete _rec;
                 }
             
                 sf::Shape* get_shape() final {
                     return _rec;
                 }
             
             private:
                 sf::RectangleShape*    _rec;
                 size_t                 _width;
                 size_t                 _height;
                 size_t                 _x;
                 size_t                 _y;
             };
             
             class circle_asset : public asset {
             public:
                 circle_asset(size_t radius, size_t sides, size_t x, size_t y) {
                     _cir    = new sf::CircleShape(radius,sides);
                     _radius = radius;
                     _sides  = sides;
                     _x      = x;
                     _y      = y;
                     
                     _cir->setPosition(_x,_y);
                     _cir->setOutlineColor(sf::Color::Blue);
                     _cir->setOutlineThickness(3);
                 }
             
                 ~circle_asset() {
                     delete _cir;
                 }
             
                 sf::Shape* get_shape() final {
                     return _cir;
                 }
             
             private:
                 sf::CircleShape*    _cir;
                 size_t              _radius;
                 size_t              _sides;
                 size_t              _x;
                 size_t              _y;
             };
             
             class main_window {
             public:
                 main_window(size_t width, size_t height, std::string title) {
                     _window = new sf::RenderWindow(sf::VideoMode(width, height), title);
                     _window->setFramerateLimit(60);
                 }
             
                 ~main_window() {
                     delete _window;
                 }
             
                 void main_loop() {
                     while (_window->isOpen()) {
                         sf::Event event;
                         while (_window->pollEvent(event)) {
                             if (event.type == sf::Event::Closed) {
                                 _window->close();
                             }
                         }
                         _window->setActive();
                         draw_assets();
                         _window->display();
                     }
                 }
             
                 void add_asset(asset* asset) {
                     _assets.push_back(asset);
                 }
             
                 void draw_assets() {
                     for (const auto& asset : _assets) {
                         _window->draw(*asset->get_shape());
                     }
                 }
             
             private:
                 sf::RenderWindow*   _window;
                 std::vector<asset*> _assets;
             };
             
             
             int main() {
                 main_window win(800,600,"My Window");
                 
                 rectangle_asset* house_base{new rectangle_asset{300,200,250,300}};
                 rectangle_asset* door      {new rectangle_asset{ 30, 50,385,450}};
                 rectangle_asset* window0   {new rectangle_asset{ 70, 50,280,350}};
                 rectangle_asset* window1   {new rectangle_asset{ 70, 50,450,350}};
                 circle_asset*    door_knob {new circle_asset   {  5,  3,390,475}};
                 circle_asset*    roof      {new circle_asset   {180,  3,220, 28}};
                 
                 win.add_asset(house_base);
                 win.add_asset(door);
                 win.add_asset(window0);
                 win.add_asset(window1);
                 win.add_asset(door_knob);
                 win.add_asset(roof);
                 
                 win.main_loop();
                 
                 return 0;
             }
	     ```
	     
[X][12] (*2) Define interfaces for `warrior`, `monster`, and `object` (that is a thing you can pick up, drop, use, etc.) classes for an adventure-style game.
             ```
	     struct warrior;
             struct monster;
             struct object;
             
             struct warrior {
                 virtual ~warrior();
                 virtual void attack(monster& m) = 0;
                 virtual void use(object& o)     = 0;
             };
             
             struct monster {
                 virtual ~monster();
                 virtual void   attack(warrior& m) = 0;
                 virtual object loot()             = 0;
             };
             
             struct object {
                 virtual ~object();
                 virtual void consume() = 0;
                 virtual void drop()    = 0;
             };
	     ```
	     
[X][14] (*3) Outline an implementation strategy.
	     - I've grown fond of the plugin design strategy. Where the application is a singleton static object of class that is designed to interface
	     with an arbitrary amount of plugins. Yes, certain plugins may depend on other plugins, but this idea can be represented abstractly and
	     effectively through code when paying the right amount of attention to the details of the implementation.

----------------------
X.22 Class Hierarchies
----------------------
[X][19] (*2) Describe memory layout.
	     - The layout of memory is vital to gain a deep understanding of what's "under-the-hood" of a machine.
	     The first thing to note is that memory addresses as seen from our point of view are virtual in relation to the physical memory on the machine.
	     This is to provide us with a robust layout of memory.
	     An intel x86 processor running in 64-bit mode has access to 2^64-1 virtual memory addresses; with access to 2^46-1 physical memory bytes.
	     An intel x86 processor running in 34-bit mode has access to 2^32-1 virtual memory addresses; with access to 2^36-1 physical memory bytes.
	     An intel 8086 processor has access to 2^20-1 virtual memory addresses.
	     According to my current understandingthat the high-order memory addresses are reserved for the kernel; the bottom are for the user;
	     stack/program segments/etc.

------------------------------
X.23 Run-Time Type Information
------------------------------
[X][1] (*1) Test all permutations of `static_cast`, `dynamic_cast`, and `reinterpret_cast`.
            - This program does not test all permutations of the different casts, but instead gave me a good lesson on how resilient the type system is.
	    Therefore, I call that a win.
            ```
	    #include <iostream> // std::cout

            struct animal {
                virtual void f() {
                    std::cout << "animal\n";
                }
            };
            
            struct dog : animal {
                virtual void f() final {
                    std::cout << "dog\n";
                }
            };
            
            struct cat : animal {
                virtual void f() final {
                    std::cout << "cat\n";
                }
            };
            
            // Due to the type system I'm unable to use this code in the exercise.
            // But it was a good lesson to learn, and should be kept in mind.
            enum class cast_flag : size_t {
                sc_ani = 1,
                dc_ani = 2,
                rc_ani = 4,
                sc_dog = 8,
                dc_dog = 16,
                rc_dog = 32,
                sc_cat = 64,
                dc_cat = 128,
                rc_cat = 256
            };
            
            cast_flag operator |(const cast_flag& lhs, const cast_flag& rhs) {
                return static_cast<cast_flag>(static_cast<size_t>(lhs) | static_cast<size_t>(rhs));
            }
            
            // template<typename T>
            void test_casts(animal* p, cast_flag flag) {
                for (size_t i{0}; i < 9; ++i) {
                    if ((static_cast<size_t>(flag) >> i) & 0x01) {
            
                        // Note the `1<<i` for getting the correct flag.
                        switch (static_cast<cast_flag>(1<<i)) { 
                            
                            case cast_flag::sc_ani:
                                static_cast<animal*>(p)->f();
                                break;
                                
                            case cast_flag::dc_ani:
                                dynamic_cast<animal*>(p)->f();
                                break;
                                
                            case cast_flag::rc_ani:
                                reinterpret_cast<animal*>(p)->f();
                                break;
                                
                            case cast_flag::sc_dog:
                                static_cast<dog*>(p)->f();
                                break;
                                
                            case cast_flag::dc_dog:
                                dynamic_cast<dog*>(p)->f();
                                break;
                                
                            case cast_flag::rc_dog:
                                reinterpret_cast<dog*>(p)->f();
                                break;
                                
                            case cast_flag::sc_cat:
                                static_cast<cat*>(p)->f();
                                break;
                                
                            case cast_flag::dc_cat:
                                dynamic_cast<cat*>(p)->f();
                                break;
                                
                            case cast_flag::rc_cat:
                                reinterpret_cast<cat*>(p)->f();
                                break;
                        }
                    }
                }
            }
            
            // #define TEST_CASTS(arg)                  \
            //     static_cast<animal*>(arg)->f();      \
            //     dynamic_cast<animal*>(arg)->f();     \
            //     reinterpret_cast<animal*>(arg)->f(); \
            //                                          \
            //     static_cast<dog*>(arg)->f();         \
            //     dynamic_cast<dog*>(arg)->f();        \
            //     reinterpret_cast<dog*>(arg)->f();    \
            //                                          \
            //     static_cast<cat*>(arg)->f();         \
            //     dynamic_cast<cat*>(arg)->f();        \
            //     reinterpret_cast<cat*>(arg)->f();
            
            int main() {
                animal   a; dog   d; cat   c;
                animal* ap; dog* dp; cat *cp;
            
                // ap = &a;
                // test_casts(ap, cast_flag{ cast_flag::sc_ani   |   cast_flag::dc_ani   |   cast_flag::rc_ani   |
                //                           cast_flag::sc_dog   |   cast_flag::dc_dog   |   cast_flag::rc_dog   |
                //                           cast_flag::sc_cat   |   cast_flag::dc_cat   |   cast_flag::rc_cat });
                
                // dp = &d;
                // test_casts(dp, cast_flag{ cast_flag::sc_ani   |   cast_flag::dc_ani   |   cast_flag::rc_ani   |
                //                           cast_flag::sc_dog   |   cast_flag::dc_dog   |   cast_flag::rc_dog   |
                //                         /*cast_flag::sc_cat   |*/ cast_flag::dc_cat   |   cast_flag::rc_cat });
                
                // cp = &c;
                // test_casts(ap, cast_flag{ cast_flag::sc_ani   |   cast_flag::dc_ani   |   cast_flag::rc_ani   |
                //                         /*cast_flag::sc_dog*/ |   cast_flag::dc_dog   |   cast_flag::rc_dog   |
                //                           cast_flag::sc_cat   |   cast_flag::dc_cat   |   cast_flag::rc_cat });    
                
                return 0;
            }
	    ```
	     
[X][2] (*2) Write a program that illustrates the sequence of constructor calls at the state of an object relative to RTTI during
            construction. Similarly illustrate destruction.
	    ```
	    #include <iostream> // std::cout

            struct animal {
                 animal() { std::cout << "construcing `animal`\n"; }
                ~animal() { std::cout << "destructing `animal`\n"; }
            };
            
            struct dog : animal {
                 dog() { std::cout << "construcing `dog`\n"; }
                ~dog() { std::cout << "destructing `dog`\n"; }
            };
            
            struct dalmation : dog {
                 dalmation() { std::cout << "construcing `dalmation`\n"; }
                ~dalmation() { std::cout << "destructing `dalmation`\n"; }
            };
            
            int main() {
                dalmation d;
                return 0;
            }
	    ```

--------------
X.24 Templates
--------------
[X][5]  (*2) Define a `sort()` that takes its comparison criterion as a template argument.
	     ```
	     #include <algorithm> // std::swap
	     #include <iostream>  // std::cout
             #include <vector>    // std::vector
             
             template<typename T, typename U>
             void sort(std::vector<T>& vec, U criterion) {
                 bool sorted{false};
                 while (!sorted) {
                     sorted = true;
                     for (size_t i{0}; i < vec.size()-1; ++i) {
                         if (!criterion(vec[i], vec[i+1])) {
                             std::swap(vec[i], vec[i+1]);
                             sorted = false;
                         }
                     }
                 }
             }
             
             template<typename T>
             auto less    { [](const T& lhs, const T& rhs) {return (lhs <  rhs);} };
             template<typename T>
             auto less_eq { [](const T& lhs, const T& rhs) {return (lhs <= rhs);} };
             template<typename T>
             auto great   { [](const T& lhs, const T& rhs) {return (lhs >  rhs);} };
             template<typename T>
             auto great_eq{ [](const T& lhs, const T& rhs) {return (lhs <= rhs);} };
             
             int main() {
                 std::vector<int> vec{4,3,6,7,9,1,2,5,0,8};
                 
                 for (const auto& e : vec) {
                     std::cout << e << ' ';
                 }
                 std::cout << '\n';
             
                 sort(vec, less<int>);
             
                 for (const auto& e : vec) {
                     std::cout << e << ' ';
                 }
                 std::cout << '\n';
                 
                 return 0;
             }
	     ```
         
----------
X.31 Other
----------
[X][1] (*1) How many standard-library header files are there? If you could have only ten, which ten would you choose?
            - `libcxx`:
               /libcxx/include/                 132
	       /libcxx/include/experimental/    30
	       /libcxx/include/ext/             3
	       /libcxx/include/support/android/ 1
	       /libcxx/include/support/fuchsia/ 1
	       /libcxx/include/support/ibm/     4
	       /libcxx/include/support/musl/    1
	       /libcxx/include/support/newlib/  1
	       /libcxx/include/support/solaris/ 3
	       /libcxx/include/support/win32/   2
	       /libcxx/include/support/xlocale/ 3
	       total:                           181

            - On my system the relevent files are:
	      /c++/7/                   89
	      /c++/7/backward/          8
	      /c++/7/bits/              124
	      /c++/7/debug/             32
	      /c++/7/decimal/           2
	      /c++/7/experimental/      30
	      /c++/7/experimental/bits/ 8
	      /c++/7/ext/               44
	      /c++/7/parallel/          43
	      /c++/7/profile/           19
	      /c++/7/tr1/               62
	      /c++/7/tr2/               6
	      total:                    467
	      
	    - I would choose:
	      /c++/7/algorithm
	      /c++/7/chrono
	      /c++/7/deque
	      /c++/7/exception
	      /c++/7/fstream
	      /c++/7/initializer_list
	      /c++/7/iostream
	      /c++/7/map
	      /c++/7/string
	      /c++/7/vector

[ ][2] (*2) There is no `sort()` for bidirectional iterators. The conjecture is that copying to a vector and then sorting is faster than sorting a
            sequence using bidirectional iterators. Implement a general sort for bidirectional iterators and test the conjecture.
	    ```
	    
	    ```
	     
[ ][3] (*2) Complete and test a pool allocator for objects of type `T`. Make sure that Pool_alloc provides all of the facilities of the standard library
            allocator. Compare the performance of `std::allocator` and `pool_alloc` to see if there is any reason to use a `pool_alloc` on your system.
```
template<typename T>
class pool_alloc {
    T* allocate(size_t n);           // allocate space for n objects of type T; do not initialize
    void deallocate(T* p, size_t n); // deallocate space for n ojects of type T starting at p
    // ...
};
```          
            ```
	    
	    ```

[ ][4] (*2) Imagine that reading medium-long strings (most are 5 to 25 characters long) from `std::cin` is the bottleneck in your system. Write an input
            function that reads such strings as fast as you can think of. You can choose the interface to that function to optimize for speed rather than for
            convenience. Compare the result to operator `>>` in `std::string`.
	    ```
	    
	    ```
	     
[ ][5] (*2) Trace a character's route through your system from the keyboard to the screen.
            - 
```
char c;
std::cin  >> c;
std::cout << c << '\n';
```

[ ][6] (*2) Use `std::clock()` to determine average cost of: a function call, a virtual function call, reading a char, reading a 1-digit int,
            reading a 5-digit int, reading a 5-digit double, a 1-character string, a 5-character string, and a 40-character string.
	    ```
	    
	    ```
