1) The following function in the code snippet successfully takes `const char[]`??
   How is this?

// #include <iostream> // std::cout
// #include <string>   // std::string

// size_t count_occurances(const std::string& pair, const std::string& str) {
    
//     std::string tmp    {str};
//     size_t      count  {};
//     size_t      finder {tmp.find(pair)};

//     while(finder != std::string::npos) {
//         ++count;

//         tmp = std::string(tmp, finder);
//         tmp.erase(0, pair.length());

//         finder = tmp.find(pair);
//     }

//     return count;
// }
    
// }

// int main() {
//     const std::string s_pair{"ab"};
//     const std::string s_str {"xabaacbaxabb"};

//     const char c_pair[]{"ab"};
//     const char c_str []{"xabaacbaxabbab"};

//     std::cout << count_occurances(s_pair, s_str) << '\n';
//     std::cout << count_occurances(c_pair, c_str) << '\n';

//     return 0;
// }

- How to correctly check for overflow and underflow without depending on proper undefined behavior?

- What does this phrase mean, "If a side effect on a scalar object is
  unsequenced relative to another side effect on the same scalar
  object, the behavior is undefined."?

2) Why is it that I get a segfault when trying to test this "try-catch-block" in a for-loop but not
   otherwise?

// #include <chrono>    // std::chrono::high_resolution_cloc
// #include <exception> // std::exception
// #include <iostream>  // std::cout

// using namespace std::chrono;

// static high_resolution_clock::time_point t1;
// static high_resolution_clock::time_point t2;
// static size_t current_call_depth{0};
                        
// #define MEASURE_START                            \
//     std::cout << "---STARTING MEASUREMENT---\n"; \
//     t1 = high_resolution_clock::now();           \
                                
// #define MEASURE_STOP                                           \
//     t2 = high_resolution_clock::now();                         \
//     auto duration{duration_cast<microseconds>(t2-t1).count()}; \
//     std::cout << "Duration: " << duration << '\n';             \
//     std::cout << "---STOPPING MEASUREMENT---\n\n";

// #define CALL_FUNCTION(LETTER)                                   \
//     ++current_call_depth;                                       \
//     if (current_call_depth == n) {                              \
//         current_call_depth = 0;                                 \
//         MEASURE_START                                           \
//         throw std::runtime_error{"Thrown in `call_"#LETTER"`"}; \
//     }                                                           \
//     call_##LETTER(n);

// void call_a(size_t n);
// void call_b(size_t n);

// void call_a(size_t n) {
//     CALL_FUNCTION(b)
// }

// void call_b(size_t n) {
//     CALL_FUNCTION(a)
// }

// int main () {
//     try {
//         call_a(100000);
//     }
//     catch (const std::exception& e) {
//         std::cout << e.what() << '\n';
//         MEASURE_STOP
//     }
    
//     return 0;
// }
