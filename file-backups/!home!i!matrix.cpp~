#include <initializer_list>
#include <iostream>
#include <vector>

template<typename M>
std::enable_if<Matrix_type<M>(), ostream&>
operator<<(std::ostream& os, const M& m) {
    os << '{';
    for (size_t i{0}; i != rows(m); ++i) {
        os << m[i];
        if(i+1 != rows(m))
            os << ',';
    }
    return os << '}';
}

template<typename T, size_t N>
class Matrix {
public:
   static constexpr size_t order = N;
   using value_type = T;
   using iterator = typename std::vector<T>::iterator;
   using const_iterator = typename std::vector<T>::const_iterator;

   Matrix() = default;
   Matrix(Matrix&&) = default;
   Matrix& operator=(Matrix&&) = default;
   Matrix(const Matrix&) = default;
   Matrix& operator=(const Matrix&) = default;
   ~Matrix() = default;


   template<typename U>
   Matrix(const Matrix_ref<U,N>&);
   template<typename U>
   Matrix& operator=(const Matrix_ref<U,N>&);

   template<typename... Exts>
   explicit Matrix(Exts... exts);

   Matrix(Matrix_initializer<T,N>);
   Matrix& operator=(Matrix_initializer<T,N>);

   template<typename U>
   Matrix(std::initializer_list<U>) = delete;
   template<typename U>
   Matrix& operator=(std::initializer_list<U>) = delete;

   size_t extent(size_t n) const { return desc.extents[n]; }
   size_t size() const { return elems.size(); }
   const Matrix_slice<N>& descriptor() const { return desc; }

   T* data() { return elems.data(); }
   const T* data() const { return elems.data(); }

   template<typename... Args>
   std::enable_if<Matrix_impl::Requesting_element<Args...>(), T&>
   operator()(Args... args);
   
   template<typename... Args>
   std::enable_if<Matrix_impl::Requesting_element<Args...>(), const T&>
   operator()(Args... args) const;

   template<typename... Args>
   std::enable_if<Matrix_impl::Requesting_slice<Args...>(), Matrix_ref<T, N>>
   operator()(Args... args);

   template<typename... Args>
   std::enable_if<Matrix_impl::Requesting_slice<Args...>(), Matrix_ref<const T, N>>
   operator()(Args... args);

private:
   Matrix_slice<N> desc;
   std::vector<T> elems;
};

template<typename T, size_t N>
template<typename... Exts>
Matrix<T, N>::Matrix(Exts... exts)
   : desc{exts...}, elems(desc.size)
{}

template<typename T, size_t N>
Matrix<T, N>::Matrix(Matrix_initializer<T, N> init) {
   desc.extents = Matrix_impl::derive_extents(init);
   Matrix_impl::compute_strides(desc);
   elems.reserve(desc.size);
   Matrix_impl::insert_flat(init, elems);
   assert(elems.size() == desc.size);
}

template<typename T, size_t N>
template<typename U>
Matrix<T, N>::Matrix(const Matrix_ref<U, N>& x)
   : desc{x.desc}, elems{x.begin(), x.end()} {
      static_assert(Convertible<U, T>(), "Matrix constructor: incompatible element types")
}

template<typename T, size_t N>
template<typename U>
Matrix<T, N>::Matrix operator=(const Matrix_ref<U, N>& x) {
   static_assert(Convertible<U, T>(), "Matrix constructor: incompatible element types");

   desc = x.desc;
   elems.assign(x.begin(), x.end());
   return *this;
}

template<typename T, size_t N>
Matrix_ref<T, N-1> Matrix<T, N>::operator[](size_t) {
   return row(n);
}

int main()
{
   

   return 0;
}
