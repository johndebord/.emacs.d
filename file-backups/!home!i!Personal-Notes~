I think I work/learn best when a clear objective is given to me.
This is a reflection of the strategy I used back in late 2017, when I strived to make a program per chapter in `tcpppl`.
I don't think this was a very good approach. Although it does require creativity to solve the problem, it almost begs for a weaker form of creativity
because of its redundancy. Instead, I should save my creative prowess for when it matters, and learn with clear forethought objectives from the author;
deciding for myself and forming an opinion if the problem is worth the time investment. The weakness to this approach is that I might forego a problem where
I could have learnt something, but if this almost seems negligible in the grand scheme of things; and I've come to realize that this approach is probably
more time-effective.

I think I make my "TODO"s too massive. In the future, I should make them smaller; or segment them up a bit. I think by having them too large/taking a big
time investment, that I don't retain as much as I could. I think I should scope the "TODO"s into chuncks that should take around a week to finish; after which
I move on to another segment (and eventually coming back around to continue on where I left off on the previous segment).
I think this will not only help me retain the knowledge better, but make it more enjoyable/will get my brain more involved.
I should start this as soon as I'm done with the exercises in TCPPPL.

I posters of:
- All undefined/implementation-defined behavior in C++.
- All CPU opcodes for x86.
- ASCII table.
- Common design pattersn.
- Commong STL stuff.
- Operator precedence.
- Others I have written down somewhere.

I need to get real good and real fast at profiling code.
That way, if I come across certain snippets of code no matter where they are, I can just whip up emacs and profile the speed and/or profile the snippet
against any other snippet of my choosing.

If code doesn't change the state of the class, make said function const.

`=` operators change the state of the class; thus they shall not be made const and return a reference; `*this`.

It'd be cool to make a program that completely elliminates header files for med/large-
sized codebases, so that it would make source code navigation easier for me by a large
margin.

A cool exercise program would be to implement a sort of piano, where the keys, `a`, `s`, `d`, and `f` representing notes.
And then your right hand could operate the `up`, `down`, `left`, and `right` could operate and said notes (tones/pitches/etc.).

My first VR program should be implementing "real" vision, where the outline of the nose/hair/field-of-view is considered.

Things To Learn How To Develop/Data Formats:
- Movies
- Music
- Video Game Modding

As a programming exercise, make a super fast/simple text editor that simply opens a file for a quick edit and save. Name is `g-dolla`. There will only be a few commands: <all basic cursor movement and text editing> and `save`. Make it so it has my "custom home-row navigation binds". This program should be literally so small and dumb that it's cool.

Personal Weakness That I Must Confront:
Double-Dispatch

Implement the concept of "virtual time"

goodvariablenames

Cryptos come and go, but we're here to stay.

A good exercise would be to make an ascii GUI using xlib to show case different sorting algorithms

Don't add too many "TODO"s. Keep them at a minimal; then when there is a sufficient amount, get them all done; repeat the process.

Thoughts that came out of discussing compression strategies:
Information theory.
Hash table is the best way to compress data.
A blockchain that can store data like so.
Something about zlib for compression.
A blockchain that spins up blockchains dynamically.

To get a good high-level overview of new features; visit the file `version` and look at the new
macros that have been defined; a general idea can be drawn from said macro names.

What are all the register conventions?
Caller/Callee conventions?

Interweving markets of deciding yes/no/sharing in the rewards.

I have a new philosophy:
Rather than taking notes, I shall only try to fully comprehend the text;
The only "note-taking" that shall take place is if I'm trying to work out a problem.
For the purpose of taking notes is to retain information;
but if the information is really meant to be retaint, it shall be worthy of automation from within my text editor.
This shall save myself the time (definitely sunk-time from focusing more on the note than the idea), and be more practical.
One of the reasons that I'm doing this is because how many time have I actually gone back to my notes to look something up?
And if I truly need to remember something I should remember it without taking notes, or better yet, automate the task.
Also, notes truly worth writing down should be questions in the margins and debatebly new terms.

VCs need a liquidity event.

Email Juan about distributed systems

Just thought of something:
To prove it's efficiencty, users are allowed a sandboxed environment

PUBLICATIONS!!!!!!!