#include <cstring>
#include <stdexcept>

class bstring
{
public:
    bstring()
        : _size{0}, _begin{_sso_str}
    {
        _sso_str[0] = 0;
    }
    
    bstring(const char* s)
        : _size{strlen(s)}, _begin{(_size <= _sso_max) ? _sso_str : new char[_size + 1]}
    {
        strcpy(_begin, s);
    }
    
    bstring(const bstring& s)
    {
        copy_from(s);
    }
    
    bstring& operator=(const bstring& s)
    {
        if(this == &s)
            return *this;
        char* begin{(_sso_max < _size) ? _begin : 0};
        copy_from(s);
        delete[] begin;
        return *this;
    }
    
    bstring(bstring&& s)
    {
        move_from(s);
    }
    
    bstring& operator=(bstring&& s)
    {
        if(this == &s)
            return *this;
        if(_sso_max < _size)
            delete[] _begin;
        move_from(s);
        return *this;
    }
    
    ~bstring()
    {
        if(_sso_max < _size) delete[] _begin;
    }

    char& operator[](size_t n)
    {
        return _begin[n];
    }
    
    char operator[](size_t n) const
    {
        return _begin[n];
    }
    
    char& at(size_t n)
    {
        check(n);
        return _begin[n];
    }
    
    char at(size_t n) const
    {
        check(n);
        return _begin[n];
    }

    bstring& operator+=(char c)
    {
        if(_size == _sso_max)
        {
            size_t n = _size + _size + 2;
            _begin = expand(_begin, n);
            _space = n - _size - 2;
        }
        else if(_sso_max < _size)
        {
            if(_space == 0)
            {
                size_t n = _size + _size + 2;
                char* begin = expand(_begin, n);
                delete[] _begin;
                _begin = begin;
                _space = n - _size - 2;
            }
            else
                --_space;
        }
        
        _begin[_size] = c;
        _begin[++_size] = 0;

        return *this;
    }

    char* c_str()
    {
        return _begin;
    }
    
    const char* c_str() const
    {
        return _begin;
    }

    size_t size() const
    {
        return _size;
    }
    
    size_t capacity() const
    {
        return (_size <= _sso_max) ? _sso_max : _size + _space;
    }

private:
    static const size_t _sso_max{15};
    
    size_t _size;
    char* _begin;
    
    union
    {
        size_t _space;
        char _sso_str[_sso_max + 1];
    };
    
    void check(size_t n) const
    {
        if(n < 0 || _size <= n)
            throw std::out_of_range("bstring::at()");
    }

    char* expand(const char* s, size_t n)
    {
        char* begin{new char[n]};
        strcpy(begin, s);
        return begin;
    }

    void copy_from(const bstring& s)
    {
        if(s._size <= _sso_max)
        {
            memcpy(this, &s, sizeof(s));
            _begin = _sso_str;
        }
        else
        {
            _begin = expand(s._begin, s._size + 1);
            _size = s._size;
            _space = 0;
        }
    }
    
    void move_from(bstring& s)
    {
        if(s._size <= _sso_max)
        {
            memcpy(this, &s, sizeof(s));
            _begin = _sso_str;
        }
        else
        {
            _begin = s._begin;
            _size = s._size;
            _space = s._space;
            s._begin = s._sso_str;
            s._size = 0;
            s._sso_str[0] = 0;
        }
    }
};

char* begin(bstring& s)
{
    return s.c_str();
}

char* end(bstring& s)
{
    return s.c_str() + s.size();
}

const char* begin(const bstring& s)
{
    return s.c_str();
}

const char* end(const bstring& s)
{
    return s.c_str() + s.size();
}

bstring& operator+=(bstring& lhs, const bstring& rhs)
{
    for(auto c : rhs)
        lhs += c;
    return lhs;
}

bstring operator+(const bstring& lhs, const bstring& rhs)
{
    bstring res{lhs};
    res += rhs;
    return res;
}

bstring operator""_s(const char* s)
{
    return bstring{s};
}

int main()
{
    return 0;
}
