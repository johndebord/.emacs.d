#include <stdexcept>

class my_string
{
private:
    size_t size;
    size_t capacity;
    char* begin;
    std::allocator<char> alloc;

    //destroys and deallocates memory owned by begin
    void cleanup();

    //helper functions for my_string::insert
    my_string& reserve_and_add(const size_t n, char c);
    my_string& reserve_and_add(const size_t n, const char* s);
    void shift_and_insert(size_t pos, size_t n, char c);
    void shift_and_insert(size_t pos, const char* s, size_t s_size, size_t new_end);
    void allocate_and_insert(size_t pos, size_t n, char c);
    void allocate_and_insert(size_t pos, const char* s, size_t s_size, size_t new_end);

public:
    using value_type = char;
    using iterator = char*;
    using const_iterator = const char*;

    my_string();
    //contents must be null-terminated. otherwise, behavior is undefined.
    my_string(const char* contents);
    //stores n elements with value c in begin
    my_string(size_t n, char c);

    //copy functions perform a deep copy on rhs. space of copy arg is not copied.
    my_string(const my_string& rhs);
    my_string& operator=(const my_string& rhs);

    //like the copy functions, the move functions do not copy space of args.
    my_string(my_string&& rhs) noexcept;
    my_string& operator=(my_string&& rhs) noexcept;

    size_t size() const noexcept
    {
        return size;
    }

    //size including terminating zero
    size_t tot_size() const noexcept
    {
        return size == 0 ? 0 : size + 1;
    }

    size_t capacity() const noexcept
    {
        return capacity;
    }

    char& operator[](size_t n)
    {
        return begin[n];
    }

    const char& operator[](size_t n) const
    {
        return begin[n];
    }

    char& at(size_t n);
    const char& at(size_t n) const;

    iterator begin()
    {
        return &begin[0];
    }

    const_iterator begin() const noexcept
    {
        return &begin[0];
    }

    const_iterator cbegin() const noexcept
    {
        return &begin[0];
    }

    iterator end()
    {
        return &begin[size];
    }

    const_iterator end() const noexcept
    {
        return &begin[size];
    }

    const_iterator cend() const noexcept
    {
        return &begin[size];
    }

    //reserves space for n chars and copies old elements to new space.
    void reserve(size_t n);

    void resize(size_t n, char c);
    void resize(size_t n) { resize(n, ' '); }

    const char* c_str() const noexcept
    { 
        return begin; 
    }

    //inserts n elements with value c starting at index pos
    my_string& insert(size_t pos, size_t n, char c);
    //inserts C-style string s at index pos
    my_string& insert(size_t pos, const char* s);

    //erases count elemenets starting at index
    my_string& erase(size_t index, size_t count);
    //erases pos if it is found in begin
    iterator erase(const_iterator pos);

    void pop_back();

    void push_back(char c);

    my_string& operator+=(const my_string& rhs);
    ~my_string();
};
