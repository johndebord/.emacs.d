// TODO: replace `map` with `unordered_map`
// TODO: Find the most optimal initialization strategies
// TODO: Possibly implement multithreading strategies that keep order consistency

#include <iostream>
#include <map>
#include <vector>

struct balance {
    int account_id; ///< The name of the account.
    int balance;    ///< The balance of the account.
};

struct transfer {
    int from;   ///< The account to transfer from.
    int to;     ///< The account to transfer to.
    int amount; ///< The amount to transfer.
};

using transactions = std::vector<transfer>;
using balances     = std::vector<balance>;

class database {
public:
    database(const balances& initial_balances) : accounts{ balances_to_map(initial_balances) }
    { }

    // // We assume that all actors are good; so no invariants are checked for faster throughput.
    void push_transaction(const transactions& t) {
        for (const auto& transfer : t) {
            // static size_t transaction_indice{};
            
            accounts[transfer.from] -= transfer.amount;
            accounts[transfer.to]   += transfer.amount;
            
            if(accounts[transfer.from] < 0 || accounts[transfer.to] < 0) {
                transfer_history.push_back(transfer);
                // ++transaction_indice;
                // continue;
            } else {
                // transfer_history.push_back(transfer);
                // applied_transactions.push_back(transaction_indice);
            }
            // ++transaction_indice;
        }
        // transfer_history.push_back(transfer);
    }
    
    void settle() {
        for (const auto& transfer : transfer_history) {
            if(accounts[transfer.from] < 0 || accounts[transfer.to] < 0) {
                accounts[transfer.from] += transfer.amount;
                accounts[transfer.to]   -= transfer.amount;
            } else
                continue;
        }
    }
    
    balances get_balances() const {
        return map_to_balances(accounts);
    }
    
    // std::vector<size_t> get_applied_transactions() const {
    //     return applied_transactions;
    // }

public:
    std::map<int, int>    accounts;             ///< Mapping of all accounts `{ account_id, balance }`.
    // std::vector<size_t>   applied_transactions; ///< Vector of all successfully applied transaction indices since last `settle()`.
    std::vector<transfer> transfer_history;     ///< Vector of all successful transfers since last `settle()`.
    // std::vector<int>      flagged_accounts;     ///< Vector of all accounts that go negative at the end of a transaction cycle.

    // Perfect mirror function of `map_to_balances`.
    std::map<int, int> balances_to_map(const balances& b) const {
        std::map<int, int> ret{};
        for (const auto& balance : b)
            ret.insert( {balance.account_id, balance.balance} );
        return ret;
    }

    // Perfect mirror function of `balances_to_map`.
    balances map_to_balances(const std::map<int, int>& m) const {
        balances ret{};
        for (const auto& pair : m)
            ret.push_back( {pair.first, pair.second} );
        return ret;
    }

    // Recursively pop all invalid transactions?
};

/**
 *
 * @param initial_balances - the initial balances in the database, see the above datastructures.
 * @return an instantiated database type of your creation which has the following member methods:
 *
 *    // push a transaction to the database
 *    //
 *    void push_transaction(const transaction& t)
 *
 *    // settle the database such that the invariant is maintained and the best state of the database is present
 *    //
 *    void settle()
 *
 *    // return a listing of all the balances in any order
 *    //
 *    vector<balance> get_balances() const
 *
 *    // return the 0-based indices of the applied transactions after settle in any order
 *    //
 *    vector<size_t> get_applied_transactions() const
 *
 * The automated test cases will call create_database with a set of initial balances
 * They will then feed a number of transactions to your class
 * They will then call settle
 * They will then call get_balances and inspect the results
 */
// database create_database(const balances& initial_balances) {
//     return /* return an instantiated class */;
// }

void print(const std::map<int, int>& m);
void test_case0(database db);
void test_case1(database db);
void test_case2(database db);
void test_case3(database db);

int main() {
    
    balances initial_balances{ {1,5},{2,10},{3,15} };
    database db{initial_balances};
    // test_case0(db);
    // test_case1(db);
    // test_case2(db);
    test_case3(db);
    return 0;
}

void print(const std::map<int, int>& m) {
    for (const auto& pair : m)
        std::cout << pair.first << ' ' << pair.second << '\n';
};

void test_case0(database db) {
    transactions t0 { {1,2,3},{3,1,2} };
    print(db.accounts); std::cout << '\n';
    db.push_transaction(t0);
    db.settle();
    print(db.accounts); std::cout << '\n';
}

void test_case1(database db) {
    transactions t0 { {1,2,3},{3,1,2} };
    transactions t1 { {2,1,11} };
    print(db.accounts); std::cout << '\n';
    db.push_transaction(t0);
    db.push_transaction(t1);
    // db.settle();
    print(db.accounts); std::cout << '\n';
}

void test_case2(database db) {
    transactions t0 { {2,1,11} };
    print(db.accounts); std::cout << '\n';
    db.push_transaction(t0);
    db.settle();
    print(db.accounts); std::cout << '\n';
}

void test_case3(database db) {
    transactions t0 { {2,1,11} };
    transactions t1 { {1,2,3}, {3,1,2} };
    print(db.accounts); std::cout << '\n';
    db.push_transaction(t0);
    db.push_transaction(t1);
    db.settle();
    print(db.accounts); std::cout << '\n';
}
