////////////////////////////////////////////////////////////////////////////////

/*
 * Safe-math mini-lib for the naive.
 * Prevents overflow.
 * Note: There's always an opportunity for optimization.
 */

#include <cassert>
#include <cstdint>
#include <type_traits>

namespace eosio {

    template<typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
    constexpr T mul(T a, T b) {
        if(a == 0 || b == 0)
            return 0;
        else {
            T c{a * b};
            eosio_assert((c / a) == b, "mul" );
            return c;
        }
    }

    template<typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
    constexpr T div(T a, T b) {
        eosio_assert(0 < b, "div" );
        T c{a / b};
        assert(a == (b * c + a % b));
        return c;
    }

    template<typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
    constexpr T sub(T a, T b) {
        eosio_assert(b <= a, "sub" );
        T c{a - b};
        return c;
    }

    template<typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
    constexpr T add(T a, T b) {
        T c{a + b};
        eosio_assert(a <= c, "add" );
        return c;
    }

    template<typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
    constexpr T mod(T a, T b) {
        eosio_assert(b != 0, "mod" );
        return (a % b);
    }
    
}

////////////////////////////////////////////////////////////////////////////////

/*
 * Math mini-lib for the naive C++ developer.
 * Note: There's always an opportunity for optimization.
 */

#include <type_traits>

namespace eosio {

    template<typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
    constexpr T min(T a, T b) {
        return (a < b) ? a : b;
    }

    template<typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
    constexpr T max(T a, T b) {
        return (a < b) ? b : a;
    }

    template<typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
    constexpr T average(T a, T b) {
        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
    }
    
}

////////////////////////////////////////////////////////////////////////////////

/*
 * Couple `core` contracts for persons wanting to impl creative abstract ideas.
 * Note: There's always an opportunity for optimization.
 */

namespace eosio {

    class ownable : public eosio::contract {
    public:
        using eosio::contract::contract;
        
        ownable(name nm) : _owner{nm}
        { }

        [[eosio::action]]
        void transfer_ownership(name nm) {
            require_auth( _self );
            _owner = nm;
        }

        [[eosio::action]]
        void renounce_ownership() {
            require_auth( _self );
            _owner = 0;
        }

        bool is_owner(name n) {
            return n == _owner;
        }

        name get_owner() {
            return _owner;
        }
    
    private:
        name _owner;      
    };

    class pausable : public eosio::contract {
    public:
        using eosio::contract::contract;
        
        ownable(bool p) : _paused{p}
        { }

        [[eosio::action]]
        void pause() {
            assert(_paused == false);
            require_auth( _self );
            _paused = true;
        }

        [[eosio::action]]
        void unpause() {
            assert(_paused == true);
            require_auth( _self );
            _paused = false;
        }

        bool paused() {
            return _paused;
        }

    private:
        bool  _paused = false;
    }
    
}

////////////////////////////////////////////////////////////////////////////////
