
class eostring {
public:    
    my_string()
        :m_contents{ nullptr }, m_size{ 0 }, m_space{ 0 }{}

    my_string(const char* contents)
        : m_size{ my_strlen(contents) }, m_space{ tot_size()},
          m_contents{ alloc.allocate(m_space) }
    {
        for (int i = 0; i < m_size; ++i)
        {
            alloc.construct(&m_contents[i], contents[i]);
        }
        alloc.construct(&m_contents[m_size], '\0');
    }

    my_string(size_t size, char c)
        :m_size{ size }, m_space{ size + 1 },
         m_contents{ alloc.allocate(m_space) }
    {
        for (int i = 0; i < m_size; ++i)
        {
            alloc.construct(&m_contents[i], c);
        }
        alloc.construct(&m_contents[m_size], '\0');
    }

    my_string(const my_string& rhs)
        :m_size{ rhs.m_size }, m_space{ rhs.tot_size() },
         m_contents{ alloc.allocate(m_space) }
    {
        for (int i = 0; i < m_size; ++i)
        {
            alloc.construct(&m_contents[i], rhs.m_contents[i]);
        }
        alloc.construct(&m_contents[m_size], '\0');
    }

    my_string& operator=(const my_string& rhs)
    {
        char* temp = alloc.allocate(rhs.tot_size());
        for (int i = 0; i < rhs.m_size; ++i)
        {
            alloc.construct(&temp[i], rhs.m_contents[i]);
        }
        alloc.construct(&temp[rhs.m_size], '\0');
        cleanup();
        m_contents = temp;
        m_size = rhs.m_size;
        m_space = tot_size();
        return *this;
    }

    my_string(my_string&& rhs) noexcept
    :m_size{ rhs.m_size }, m_space{ rhs.tot_size() },
        m_contents{ rhs.m_contents }
    {
        rhs.m_contents = nullptr;
        rhs.m_size = rhs.m_space = 0;
    }

    my_string& operator=(my_string&& rhs) noexcept
    {
        cleanup();
        m_contents = rhs.m_contents;
        m_size = rhs.m_size;
        m_space = tot_size();
        rhs.m_contents = nullptr;
        rhs.m_size = rhs.m_space = 0;
        return *this;
    }

    char & at(size_t n)
    {
        if (n >= m_size) throw std::out_of_range{ "invalid index passed to my_string::at" };
        return m_contents[n];
    }

    const char & at(size_t n) const
    {
        if (n >= m_size) throw std::out_of_range{ "invalid index passed to my_string::at" };
        return m_contents[n];
    }


//reserves new uninitialized space by reallocating. can only reserve 
// more than the current space
    void reserve(size_t n)
    {
        if (n <= m_space) return;
        char* temp = alloc.allocate(n);
        if (m_size)
        {
            for (int i = 0; i < tot_size(); ++i)
            {
                alloc.construct(&temp[i], m_contents[i]);
            }
            for (int i = 0; i < tot_size(); ++i)
            {
                alloc.destroy(&m_contents[i]);
            }
        }
        alloc.deallocate(m_contents, m_space);
        m_contents = temp;
        m_space = n;
    }

    void resize(size_t n, char c)
    {
        if (n > m_space) reserve(n + 1);
        for (int i = n; i < tot_size(); ++i) alloc.destroy(&m_contents[i]);
        for (int i = m_size; i < n; ++i) alloc.construct(&m_contents[i], c);
        alloc.construct(&m_contents[n], '\0');
        m_size = n;
    }


    my_string & reserve_and_add(const size_t n, char c)
    {
        reserve(n + 1);
        for (int i = 0; i < n; ++i) alloc.construct(&m_contents[i], c);
        alloc.construct(&m_contents[n], '\0');
        m_size += n;
        return *this;
    }

    my_string & reserve_and_add(const size_t n, const char * s)
    {
        reserve(n + 1);
        for (int i = 0; i < n + 1; ++i) alloc.construct(&m_contents[i], s[i]);
        m_size += n;
        return *this;
    }

//the elements in the range [new_end, new_end - elems_moving)
//are the ones that will be shifted n spaces to the right for 
//both shift_and_insert functions
    void shift_and_insert(size_t pos, size_t n, char c)
    {
        const auto elements_moving = (tot_size()) - pos;
        const auto new_end = m_size + n;
        for (auto i = new_end; i > new_end - elements_moving; --i)
        {
            m_contents[i] = m_contents[i - n];
        }
        for (int i = 0; i < n; ++i)
        {
            m_contents[pos + i] = c;
        }
    }

    void shift_and_insert(size_t pos, const char * s, size_t s_size, size_t new_end)
    {
        const int elements_moving = tot_size() - pos;
        for (auto i = new_end; i > new_end - elements_moving; --i)
        {
            m_contents[i] = m_contents[i - s_size];
        }
        for (auto i = 0; i < s_size; ++i)
        {
            m_contents[pos + i] = s[i];
        }
    }

    void allocate_and_insert(size_t pos, size_t n, char c)
    {
        //allocate more memory than needed to save for future insertion operations
        char* temp = alloc.allocate(m_space * 2 + n);
        //initialize elements before insertion, the insertion itself, then elements after
        for (auto i = 0; i < pos; ++i) alloc.construct(&temp[i], m_contents[i]);
        for (auto i = 0; i < n; ++i) alloc.construct(&temp[pos + i], c);
        for (auto i = pos; i < m_size; ++i)
        {
            alloc.construct(&temp[i + n], m_contents[i]);
        }
        alloc.construct(&temp[size() + n], '\0');
        cleanup();
        m_contents = temp;
    }

    void allocate_and_insert(size_t pos, const char * s, size_t s_size, size_t new_end)
    {
        char* temp = alloc.allocate(tot_size() + s_size);
        for (int i = 0; i < pos; ++i)
        {
            alloc.construct(&temp[i], m_contents[i]);
        }
        for (int i = 0; i < s_size; ++i)
        {
            alloc.construct(&temp[pos + i], s[i]);
        }
        for (auto i = pos; i < m_size; ++i)
        {
            alloc.construct(&temp[i + s_size], m_contents[i]);
        }
        alloc.construct(&temp[new_end], '\0');
        m_contents = temp;
        m_space = m_size + s_size + 1;
    }

//inserts n elements starting at index pos with the value of c
//checks to see if there is already enough in the reserve; 
//otherwise, allocates new memory
    my_string & insert(size_t pos, size_t n, char c)
    {
        if (pos > size()) throw std::out_of_range{ "Invalid index arg to my_string::insert" };

        if (size() == 0) return reserve_and_add(n, c);

        if (n + m_size <= m_space) shift_and_insert(pos, n, c);

        else allocate_and_insert(pos, n, c);

        m_size += n;
        return *this;
    }

    my_string& insert(size_t pos, const char* s)
    {
        if (pos > size()) throw std::out_of_range{ "Invalid index arg to my_string::insert" };

        const int s_size = my_strlen(s);

        if (size() == 0) return reserve_and_add(s_size, s);

        const int new_end = size() + s_size;

        if (s_size + tot_size() <= m_space) shift_and_insert(pos, s, s_size, new_end);

        else allocate_and_insert(pos, s, s_size, new_end);

        m_size += s_size;
        return *this;
    }

    my_string & erase(size_t index, size_t count)
    {
        if (index >= m_size) throw std::out_of_range{ "out of range index to my_string::erase" };
        if (m_size == 0 || count == 0) return *this;
        //don't want to remove more elems than there are in the string
        const auto num_elems_removing = min(m_size - index, count);
        const auto num_elems_shifting = m_size - (index + num_elems_removing);
        const auto new_size = m_size - num_elems_removing;
        for (int i = 0; i < num_elems_shifting; ++i)
        {
            m_contents[i + index] = m_contents[i + index + num_elems_removing];
        }
        for (int i = new_size; i < tot_size(); ++i)
        {
            alloc.destroy(&m_contents[i]);
        }
        m_size = new_size;
        alloc.construct(&m_contents[m_size], '\0');
        return *this;
    }

    iterator erase(const_iterator pos)
    {
        auto elem = std::find(begin(), end(), *pos);
        if (elem == end()) return elem;

        //this loop also copies back the terminating zero
        for (auto iter = elem; iter != end(); ++iter)
        {
            *iter = *(iter + 1);
        }
        --m_size;
        return elem;
    }

    void pop_back()
    {
        if (m_size == 0) return;
        m_contents[m_size - 1] = '\0';
        alloc.destroy(&m_contents + m_size);
        //destroy old terminating zero
        alloc.destroy(&m_contents + m_size + 1);
        --m_size;
    }

    void push_back(char c)
    {
        if (m_space == 0) reserve(8);
        else if (tot_size() == m_space) reserve(2 * m_space);
        alloc.construct(&m_contents[size()], c);
        alloc.construct(&m_contents[size() + 1], '\0');
        ++m_size;
    }

    my_string & operator+=(const my_string & rhs)
    {
        return insert(m_size, rhs.c_str());
    }

    my_string::~my_string()
    {
        cleanup();
    }

    std::ostream & operator<<(std::ostream & os, const my_string & rhs)
    {
        return os << rhs.c_str();
    }

    void cleanup()
    {
        for (int i = 0; i < tot_size(); ++i) alloc.destroy(&m_contents[i]);
        alloc.deallocate(m_contents, m_space);
    }

    size_t my_strlen(const char* str)
    {
        size_t size = 0;
        while (*str)
        {
            ++size;
            ++str;
        }
        return size;
    }
};
