(defun jd:construct-mode-folder ()
  "Automates the construction of a mode directory for customization.
[ ] TODO: Add feature to insert templates for rebinding all keymaps and
their respective keybinds by parsing through their respective files.
As a reminder:
v   = variable
pt  = package type
pn  = package name
pfp = package folder path
ps  = package string
pkb = package keybindings
pst = package settings"
  (interactive)
  (let ((jd:pt nil)
	(jd:pn nil))
    (setq jd:pt (read-from-minibuffer "Please enter the mode-type: "))
    (if (not (or (equal jd:pt "external")
                 (equal jd:pt "internal")))
	(error "Please enter a valied mode-type"))
    (setq jd:pn (read-from-minibuffer "Please enter the mode-name: "))
    (if (y-or-n-p (format "Is \"%s\" and \"%s\" correct?" jd:pt jd:pn))
	(progn
	  (let* ((jd:v-str
                  (if (equal jd:pt "external") "jd:external-prefix" "jd:internal-prefix"))
                 (jd:pfp
                  (if (equal jd:pt "external") jd:external-prefix jd:internal-prefix))
		 (jd:ps
                  (concat "jd:" jd:pn ".el"))
		 (jd:pkb-str
                  (concat "jd:" jd:pn "-kb.el"))
		 (jd:pst-str
                  (concat "jd:" jd:pn "-st.el"))
                 (jd:x.el-str
                  (concat ";; (require ' (concat jd:lisp-prefix \".elc\"))\n\n"
                          "(require '" jd:pkb-str " (concat jd:path-prefix " jd:v-str " \"" jd:pn "/" jd:pkb-str"\"))\n"
                          "(require '" jd:pst-str " (concat jd:path-prefix " jd:v-str " \"" jd:pn "/" jd:pst-str"\"))\n\n"
                          "(provide '" jd:ps ")\n"))
                 (jd:x-kb.el-str
                  (concat ";; (defun jd:-map ()\n"
	                  ";;   (setf (cdr -map) nil)\n"
	                  ";;   (define-key -map (kbd "") '))\n"
	                  ";; (add-hook '-mode-hook 'jd:-map)\n\n"
	                  "(provide '" jd:pkb-str ")\n"))
                 (jd:x-st.el-str
                  (concat "(provide '" jd:pst-str ")\n")))
	    (shell-command (concat "mkdir " jd:path-prefix jd:pfp "/" jd:pn))
	    (shell-command (concat "touch " jd:path-prefix jd:pfp "/" jd:pn "/" jd:ps))
	    (shell-command (concat "touch " jd:path-prefix jd:pfp "/" jd:pn "/" jd:pkb-str))
	    (shell-command (concat "touch " jd:path-prefix jd:pfp "/" jd:pn "/" jd:pst-str))
            (with-temp-file (concat jd:path-prefix jd:pfp "/" jd:pn "/" jd:ps)
	      (insert jd:x.el-str))
            (with-temp-file (concat jd:path-prefix jd:pfp "/" jd:pn "/" jd:pkb-str)
	      (insert jd:x-kb.el-str))
            (with-temp-file (concat jd:path-prefix jd:pfp "/" jd:pn "/" jd:pst-str)
	      (insert jd:x-st.el-str))
	    (let ((jd:match nil)
		  (jd:matches nil)
		  (jd:match-pos nil)
		  (jd:new-buffer-string nil))
	      (with-temp-buffer
		(insert-file-contents (concat jd:path-prefix jd:pfp "jd:" jd:pt "-config.el"))
		(goto-char 1)
		(while (search-forward-regexp "jd:.*.el\s" nil t 1)
		  (setq jd:match (match-string-no-properties 0))
		  (setq jd:match-pos (string-match (match-string-no-properties 0) (buffer-string)))
		  (push (cons jd:match jd:match-pos) jd:matches))
		(while (and (string< jd:ps (caar jd:matches))
                            (not (null jd:matches)))
		  (pop jd:matches))
		(if (eq jd:matches nil)
                    (progn
		      (goto-char 1)
                      (newline)
                      (previous-line))
		  (progn
		    (goto-char (cdr (car jd:matches)))
		    (end-of-line)
                    (newline)))
		(insert
		 (concat "(require '" jd:ps " (concat jd:path-prefix " jd:v-str " \"" jd:pn "/" jd:ps "\"))"))
		(setq jd:new-buffer-string (buffer-string)))
	      (with-temp-file (concat jd:path-prefix jd:pfp "/" "jd:" jd:pt "-config.el")
		(insert jd:new-buffer-string)))))
      (error "Please give valid arguments"))))

(defun jd:copy-line-and-goto-beg ()
  (interactive)
  (back-to-indentation)
  (copy-region-as-kill (point) (point-at-eol))
  (back-to-indentation)
  (message "Line copied"))

(defun jd:copy-line-and-goto-end ()
  (interactive)
  (back-to-indentation)
  (copy-region-as-kill (point) (point-at-eol))
  (end-of-line)
  (message "Line copied"))

(defun jd:delete-line ()
  (interactive)
  (beginning-of-line)
  (delete-region (point) (progn (end-of-line) (point)))
  (delete-backward-char 1))

(defun jd:delete-word-backward ()
  (interactive)
  (delete-region
   (point)
   (progn
     (backward-word)
     (point))))

(defun jd:delete-word-forward ()
  "[ ] FIXME: Delete corresponding chars as well."
  (interactive)
  (delete-region
   (progn
     (forward-word)
     (point))
   (progn
     (backward-word)
     (point))))

(defun jd:describe-keymap (keymap)
  "[ ] TODO: Refactor to be more understandable and be more robust."
  (interactive
   (list (completing-read
          "Keymap: " (let (maps)
                       (mapatoms (lambda (sym)
                                   (and (boundp sym)
                                        (keymapp (symbol-value sym))
                                        (push sym maps))))
                       maps)
          nil t)))
  (with-output-to-temp-buffer "*Keymap*"
    (princ (format "%s\n\n" keymap))
    (princ (substitute-command-keys (format "\\{%s}" keymap)))
    (with-current-buffer standard-output ;; temp buffer
      (setq help-xref-stack-item (list #'my-describe-keymap keymap)))))

(defun jd:indent-region ()
  "[ ] TODO: Get this to work in other modes as well; in particuluar,
`fundamental-mode'.
[ ] FIXME: Check if the cursor jumps out of the current
function; if it does, let the user know and don't execute the function.
[ ] FIXME: Buggy when in `c++-mode'; fix this behavior."
  (interactive)
  (save-excursion
    (beginning-of-defun)
    (set-mark (point))
    (end-of-defun)
    (indent-for-tab-command)))

(defun jd:scroll-down ()
  (interactive "^")
  (recenter)
  (scroll-up-command)
  (move-to-window-line nil))

(defun jd:scroll-up ()
  (interactive "^")
  (recenter)
  (scroll-down-command)
  (move-to-window-line nil))

(defun jd:self-insert-space ()
  (interactive)
  (insert ?\s))

(defun jd:swap-buffers ()
  (interactive)
  (switch-to-buffer nil))

(defun jd:transpose-char-left ()
  (interactive)
  (save-excursion
    (forward-char)
    (transpose-chars -1))
  (backward-char))

(defun jd:transpose-char-right ()
  (interactive)
  (save-excursion
    (forward-char)
    (transpose-chars 1))
  (forward-char))

(defun jd:transpose-line-down ()
  (interactive)
  (save-excursion
    (next-line)
    (transpose-lines 1))
  (next-line))

(defun jd:transpose-line-up ()
  (interactive)
  (save-excursion
    (next-line)
    (transpose-lines -1))
  (previous-line))

(defun jd:truncate-xref-references ()
  "Organizes output of `xref-find-references'; narrowing it down to
just the file names where the references are found."
  (interactive)
  (next-line)
  (set-mark (point))
  (let ((b 0))
    (while (equal b 0)
      (next-line)
      (if (or (equal (string (char-after (point))) "/")
	      ;;; FIXME
	      (equal (point) (point-max)))
	  (progn
	    (delete-active-region)
	    (setq b 1))))))

(defun jd:window-backward ()
  (interactive)
  (other-window -1))

(defun jd:window-forward ()
  (interactive)
  (other-window  1))

(provide 'jd:global-functions.el)
