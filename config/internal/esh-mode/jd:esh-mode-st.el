(defalias 'ff 'find-file)

(setq-default eshell-command-map nil)
(setq-default eshell-directory-name (concat jd:internal-prefix "esh-mode/eshell"))
(setq-default eshell-output-filter-functions (remove 'eshell-handle-ansi-color eshell-output-filter-functions))

(add-to-list 'eshell-preoutput-filter-functions 'xterm-color-filter)

(defun jd:counsel-esh-history ()
  (interactive)
  (company-abort)
  (counsel-esh-history))

(defun jd:eshell-ack-or-send-input ()
  (interactive)
  (if (get-char-property (point) 'face)
      (let ((jd:save-point (point))
            (jd:char-property-value nil)
            (jd:file-name nil)
            (jd:line-number nil))
        (setq jd:char-property-value (get-char-property (point) 'face))
        (cond ((or
                (equal (nth 0 (cdr jd:char-property-value)) "#ADCF44")
                (equal (nth 0 (cdr jd:char-property-value)) "#63B4F6"))
	       (setq jd:file-name (thing-at-point 'filename 'no-properties))
	       (find-file jd:file-name)
	       (forward-line (- (line-number-at-pos))))
	      ((equal (nth 0 (cdr jd:char-property-value)) "#F0C649")
	       (setq jd:line-number (thing-at-point 'word 'no-properties))
	       (beginning-of-line)
	       (while (not (equal (nth 0 (cdr (get-char-property (point) 'face))) "#ADCF44"))
	         (forward-line -1))
	       (setq jd:file-name (thing-at-point 'filename 'no-properties))
               (goto-char jd:save-point)
	       (find-file jd:file-name)
               (goto-char (point-min))
	       (forward-line (- (string-to-number jd:line-number) 1)))))
    (eshell-send-input)))

(defun jd:eshell-beginning-of-line-or-prompt ()
  (interactive "^")
  (if (or
       (not (equal (line-number-at-pos) (save-restriction
                                          (line-number-at-pos (point-max)))))
       (equal (get-text-property (line-beginning-position) 'read-only) nil)
       (and (equal (get-text-property (line-beginning-position) 'read-only) t)
            (equal (char-before) #x24)))
      (beginning-of-line)
    (eshell-bol)))

(defun jd:eshell-clear-buffer ()
  (interactive)
  (let ((jd:minimum-viable-eshell-command-column-number 4)
        (jd:saved-column-number nil))
    (if (and (equal (line-number-at-pos) (count-lines (point-max) (point-min)))
             (>= (current-column) jd:minimum-viable-eshell-command-column-number))
        (setq jd:saved-column-number (current-column)))
    (goto-char (point-max))
    (jd:eshell-beginning-of-line-or-prompt)
    (kill-line 1)
    (let ((inhibit-read-only t))
      (erase-buffer)
      (eshell-send-input)
      (beginning-of-line)
      (backward-delete-char 1))
    (goto-char (point-max))
    (yank)
    (if (not (equal jd:saved-column-number nil))
        (move-to-column jd:saved-column-number))))

(provide 'jd:esh-mode-st.el)
